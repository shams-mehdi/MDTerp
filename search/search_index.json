{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"],"fields":{"title":{"boost":1000.0},"text":{"boost":1.0},"tags":{"boost":1000000.0}}},"docs":[{"location":"","title":"Welcome to MDTerp","text":"<p>A python project for interpreting molecular dynamics (MD) trajectory metastable state classifications from machine-learning models</p> <ul> <li>Free software: MIT License</li> <li>Documentation: https://shams-mehdi.github.io/MDTerp</li> </ul>"},{"location":"#features","title":"Features","text":"<ul> <li>Scans blackbox AI classifier models trained on MD data for feature importance.</li> </ul>"},{"location":"#demos","title":"Demos","text":"<ul> <li>Notebook 1</li> <li>Notebook 2</li> </ul>"},{"location":"MDTerp/","title":"MDTerp module","text":"<p>MDTerp.base.run - Main class for implementing MDTERP.</p> Source code in <code>MDTerp/base.py</code> <pre><code>class run:\n    \"\"\"\n    MDTerp.base.run - Main class for implementing MDTERP.\n    \"\"\"\n    def __init__(self, np_data: np.ndarray, model_function_loc: str, numeric_dict: dict = {}, angle_dict: dict = {}, sin_cos_dict:dict = {}, save_dir: str = './results/', prob_threshold: float = 0.48, point_max: int = 50, num_samples: int = 10000, cutoff: int = 15, seed: int = 0, unfaithfulness_threshold: float = 0.01, periodicity_upper: float = np.pi, periodicity_lower: float = -np.pi, alpha: float = 1.0) -&gt; None:\n        \"\"\"\n        Constructor for the MDTerp.base.run class.\n\n        Args:\n            np_data (np.ndarray): Black-box training data.\n            model_function_loc (str): Location of a human-readable file containing two functions called 'load_model()', and 'run_model()'. 'load_model' must not take any arguments and should return the black-box model. 'run_model' must be a function that takes two arguments: the model and data, and returns metastable state probabilities. Go to https://shams-mehdi.github.io/MDTerp/docs/examples/ for example files.\n            numeric_dict (dict): Python dictionary, each key represents the name of a numeric feature (non-periodic). Values should be lists with a single element with the index of the corresponding numpy array in np_data.\n            angle_dict (dict): Python dictionary, each key represents the name of an angular feature in [-pi, pi]. Values should be lists with a single element with the index of the corresponding numpy array in np_data.\n            sin_cos_dict (dict): Python dictionary, each key represents the name of an angular feature. Values should be lists with two elements using the sine, cosine indices of the corresponding numpy array in np_data.\n            save_dir (str): Location to save MDTerp results.\n            prob_threshold (float): Threshold for identifying if a sample belongs to a transition state predicted by the black-box model. If metastable state probability &gt; threshold for two different classes for a specific sample, it's suitable for analysis (Default: 0.48).\n            point_max (int): If too many suitable samples exist for a specific transition (e.g., transition between metastable state 3 and 8), point_max sets the maximum number of points chosen for further analysis. Points are chosen from a uniform distribution (Default: 50).\n            num_samples (int): Size of the perturbed neighborhood (Default: 10000). Ad hoc rule: should be proportional to the square root of the number of features.\n            cutoff (int): Maximum number of features kept for the final round of MDTerp and forward feature selection (use to improve compute time: when too many features are in the dataset and a priori it is known it is unlikely that more features than set by cutoff will be relevant).\n            seed (int): Random seed.\n            unf_threshold (float): Hyperparameter that sets a lower limit on surrogate model unfaithafulness (U). Forward feature selection ends when unfaithfulness reaches lower than this threshold.\n            periodicity_upper (float): Sets periodicity of the angular features (Default: numpy.pi).\n            periodicity_lower (float): Sets periodicity of the angular features (Default: -numpy.py).\n            alpha (float): L2 norm of Ridge regression (Default: 1.0).\n        Returns:\n            None\n        \"\"\"\n        # Initialization\n        os.makedirs(save_dir, exist_ok = True)\n        logger = log_maker(save_dir)\n        input_summary(logger, numeric_dict, angle_dict, sin_cos_dict, save_dir, np_data)\n\n        # Load black-box model\n        logger.info('Loading blackbox model from file &gt;&gt;&gt; ' + model_function_loc)\n        with open(model_function_loc, 'r') as file:\n            func_code = file.read()\n        local_ns = {}\n        exec(func_code, globals(), local_ns)\n        model = local_ns[\"load_model\"]()\n        logger.info(\"Model loaded!\")\n\n        # Identify transition states for given/training dataset\n        state_probabilities = local_ns[\"run_model\"](model, np_data)\n        points = picker_fn(state_probabilities, prob_threshold, point_max)\n        logger.info(\"Number of state transitions detected &gt;&gt;&gt; \" + str(len(list(points.keys()))))\n        logger.info(\"Probability threshold, maximum number of points per transition &gt;&gt;&gt; \" + str(prob_threshold) + \", \" + str(point_max) )\n        if len(list(points.keys())) == 0:\n            logger.info(\"No transition detected. Check hyperparamters!\")\n            raise ValueError(\"No transition detected. Check hyperparameters!\")\n        logger.info(100*'-')\n\n        # Loop over all the transitions\n        importance_master = {}\n        for transition in points:\n            logger.info(\"Starting transition &gt;&gt;&gt; \" + transition)\n            for point in range(len(points[transition])):\n                index = points[transition][point]\n                feature_type_indices, indices_names = generate_neighborhood(save_dir, numeric_dict, angle_dict, sin_cos_dict, np_data, index, seed, num_samples, np.array([]), periodicity_upper, periodicity_lower)\n                state_probabilities2 = local_ns[\"run_model\"](model, np.load(save_dir + 'DATA/make_prediction.npy'))\n                TERP_dat = np.load(save_dir + 'DATA/TERP_dat.npy')\n                selected_features = init_model(TERP_dat, state_probabilities2, cutoff, feature_type_indices, seed, alpha)\n\n                generate_neighborhood(save_dir, numeric_dict, angle_dict, sin_cos_dict, np_data, index, seed, num_samples, selected_features, periodicity_upper, periodicity_lower)\n                state_probabilities3 = local_ns[\"run_model\"](model, np.load(save_dir + 'DATA_2/make_prediction.npy'))\n                TERP_dat = np.load(save_dir + 'DATA_2/TERP_dat.npy')\n                importance_0 = final_model(TERP_dat, state_probabilities3, unfaithfulness_threshold, feature_type_indices, selected_features, seed)\n                importance = make_result(feature_type_indices, indices_names, importance_0)\n                importance_master[index] = [transition, importance]\n                logger.info(\"Completed generating \" + str(point + 1) + \"/\" + str(len(points[transition])) + \" results!\" + \" First round features kept &gt;&gt;&gt; \" + str(len(selected_features)) + \", Final round features kept &gt;&gt;&gt; \" + str(np.nonzero(importance)[0].shape[0]))\n            logger.info(100*'_')\n\n        np.save(save_dir + 'MDTerp_feature_names.npy', indices_names)\n        with open(save_dir + 'MDTerp_results_all.pkl', 'wb') as f:\n            pickle.dump(importance_master, f)\n\n        logger.info(\"Feature names saved at &gt;&gt;&gt; \" + save_dir + 'MDTerp_feature_names.npy')\n        logger.info(\"All results saved at &gt;&gt;&gt; \" + save_dir + 'MDTerp_results_all.pkl')\n\n\n        shutil.rmtree(save_dir + 'DATA')\n        shutil.rmtree(save_dir + 'DATA_2')\n        logger.info(\"Completed!!!\")\n\n        # Flush and close logger\n        for handler in logger.handlers[:]:\n            handler.close()\n            logger.removeHandler(handler)\n</code></pre>"},{"location":"MDTerp/#MDTerp.base.run.__init__","title":"<code>__init__(self, np_data, model_function_loc, numeric_dict={}, angle_dict={}, sin_cos_dict={}, save_dir='./results/', prob_threshold=0.48, point_max=50, num_samples=10000, cutoff=15, seed=0, unfaithfulness_threshold=0.01, periodicity_upper=3.141592653589793, periodicity_lower=-3.141592653589793, alpha=1.0)</code>  <code>special</code>","text":"<p>Constructor for the MDTerp.base.run class.</p> <p>Parameters:</p> Name Type Description Default <code>np_data</code> <code>np.ndarray</code> <p>Black-box training data.</p> required <code>model_function_loc</code> <code>str</code> <p>Location of a human-readable file containing two functions called 'load_model()', and 'run_model()'. 'load_model' must not take any arguments and should return the black-box model. 'run_model' must be a function that takes two arguments: the model and data, and returns metastable state probabilities. Go to https://shams-mehdi.github.io/MDTerp/docs/examples/ for example files.</p> required <code>numeric_dict</code> <code>dict</code> <p>Python dictionary, each key represents the name of a numeric feature (non-periodic). Values should be lists with a single element with the index of the corresponding numpy array in np_data.</p> <code>{}</code> <code>angle_dict</code> <code>dict</code> <p>Python dictionary, each key represents the name of an angular feature in [-pi, pi]. Values should be lists with a single element with the index of the corresponding numpy array in np_data.</p> <code>{}</code> <code>sin_cos_dict</code> <code>dict</code> <p>Python dictionary, each key represents the name of an angular feature. Values should be lists with two elements using the sine, cosine indices of the corresponding numpy array in np_data.</p> <code>{}</code> <code>save_dir</code> <code>str</code> <p>Location to save MDTerp results.</p> <code>'./results/'</code> <code>prob_threshold</code> <code>float</code> <p>Threshold for identifying if a sample belongs to a transition state predicted by the black-box model. If metastable state probability &gt; threshold for two different classes for a specific sample, it's suitable for analysis (Default: 0.48).</p> <code>0.48</code> <code>point_max</code> <code>int</code> <p>If too many suitable samples exist for a specific transition (e.g., transition between metastable state 3 and 8), point_max sets the maximum number of points chosen for further analysis. Points are chosen from a uniform distribution (Default: 50).</p> <code>50</code> <code>num_samples</code> <code>int</code> <p>Size of the perturbed neighborhood (Default: 10000). Ad hoc rule: should be proportional to the square root of the number of features.</p> <code>10000</code> <code>cutoff</code> <code>int</code> <p>Maximum number of features kept for the final round of MDTerp and forward feature selection (use to improve compute time: when too many features are in the dataset and a priori it is known it is unlikely that more features than set by cutoff will be relevant).</p> <code>15</code> <code>seed</code> <code>int</code> <p>Random seed.</p> <code>0</code> <code>unf_threshold</code> <code>float</code> <p>Hyperparameter that sets a lower limit on surrogate model unfaithafulness (U). Forward feature selection ends when unfaithfulness reaches lower than this threshold.</p> required <code>periodicity_upper</code> <code>float</code> <p>Sets periodicity of the angular features (Default: numpy.pi).</p> <code>3.141592653589793</code> <code>periodicity_lower</code> <code>float</code> <p>Sets periodicity of the angular features (Default: -numpy.py).</p> <code>-3.141592653589793</code> <code>alpha</code> <code>float</code> <p>L2 norm of Ridge regression (Default: 1.0).</p> <code>1.0</code> <p>Returns:</p> Type Description <code>None</code> <p>None</p> Source code in <code>MDTerp/base.py</code> <pre><code>def __init__(self, np_data: np.ndarray, model_function_loc: str, numeric_dict: dict = {}, angle_dict: dict = {}, sin_cos_dict:dict = {}, save_dir: str = './results/', prob_threshold: float = 0.48, point_max: int = 50, num_samples: int = 10000, cutoff: int = 15, seed: int = 0, unfaithfulness_threshold: float = 0.01, periodicity_upper: float = np.pi, periodicity_lower: float = -np.pi, alpha: float = 1.0) -&gt; None:\n    \"\"\"\n    Constructor for the MDTerp.base.run class.\n\n    Args:\n        np_data (np.ndarray): Black-box training data.\n        model_function_loc (str): Location of a human-readable file containing two functions called 'load_model()', and 'run_model()'. 'load_model' must not take any arguments and should return the black-box model. 'run_model' must be a function that takes two arguments: the model and data, and returns metastable state probabilities. Go to https://shams-mehdi.github.io/MDTerp/docs/examples/ for example files.\n        numeric_dict (dict): Python dictionary, each key represents the name of a numeric feature (non-periodic). Values should be lists with a single element with the index of the corresponding numpy array in np_data.\n        angle_dict (dict): Python dictionary, each key represents the name of an angular feature in [-pi, pi]. Values should be lists with a single element with the index of the corresponding numpy array in np_data.\n        sin_cos_dict (dict): Python dictionary, each key represents the name of an angular feature. Values should be lists with two elements using the sine, cosine indices of the corresponding numpy array in np_data.\n        save_dir (str): Location to save MDTerp results.\n        prob_threshold (float): Threshold for identifying if a sample belongs to a transition state predicted by the black-box model. If metastable state probability &gt; threshold for two different classes for a specific sample, it's suitable for analysis (Default: 0.48).\n        point_max (int): If too many suitable samples exist for a specific transition (e.g., transition between metastable state 3 and 8), point_max sets the maximum number of points chosen for further analysis. Points are chosen from a uniform distribution (Default: 50).\n        num_samples (int): Size of the perturbed neighborhood (Default: 10000). Ad hoc rule: should be proportional to the square root of the number of features.\n        cutoff (int): Maximum number of features kept for the final round of MDTerp and forward feature selection (use to improve compute time: when too many features are in the dataset and a priori it is known it is unlikely that more features than set by cutoff will be relevant).\n        seed (int): Random seed.\n        unf_threshold (float): Hyperparameter that sets a lower limit on surrogate model unfaithafulness (U). Forward feature selection ends when unfaithfulness reaches lower than this threshold.\n        periodicity_upper (float): Sets periodicity of the angular features (Default: numpy.pi).\n        periodicity_lower (float): Sets periodicity of the angular features (Default: -numpy.py).\n        alpha (float): L2 norm of Ridge regression (Default: 1.0).\n    Returns:\n        None\n    \"\"\"\n    # Initialization\n    os.makedirs(save_dir, exist_ok = True)\n    logger = log_maker(save_dir)\n    input_summary(logger, numeric_dict, angle_dict, sin_cos_dict, save_dir, np_data)\n\n    # Load black-box model\n    logger.info('Loading blackbox model from file &gt;&gt;&gt; ' + model_function_loc)\n    with open(model_function_loc, 'r') as file:\n        func_code = file.read()\n    local_ns = {}\n    exec(func_code, globals(), local_ns)\n    model = local_ns[\"load_model\"]()\n    logger.info(\"Model loaded!\")\n\n    # Identify transition states for given/training dataset\n    state_probabilities = local_ns[\"run_model\"](model, np_data)\n    points = picker_fn(state_probabilities, prob_threshold, point_max)\n    logger.info(\"Number of state transitions detected &gt;&gt;&gt; \" + str(len(list(points.keys()))))\n    logger.info(\"Probability threshold, maximum number of points per transition &gt;&gt;&gt; \" + str(prob_threshold) + \", \" + str(point_max) )\n    if len(list(points.keys())) == 0:\n        logger.info(\"No transition detected. Check hyperparamters!\")\n        raise ValueError(\"No transition detected. Check hyperparameters!\")\n    logger.info(100*'-')\n\n    # Loop over all the transitions\n    importance_master = {}\n    for transition in points:\n        logger.info(\"Starting transition &gt;&gt;&gt; \" + transition)\n        for point in range(len(points[transition])):\n            index = points[transition][point]\n            feature_type_indices, indices_names = generate_neighborhood(save_dir, numeric_dict, angle_dict, sin_cos_dict, np_data, index, seed, num_samples, np.array([]), periodicity_upper, periodicity_lower)\n            state_probabilities2 = local_ns[\"run_model\"](model, np.load(save_dir + 'DATA/make_prediction.npy'))\n            TERP_dat = np.load(save_dir + 'DATA/TERP_dat.npy')\n            selected_features = init_model(TERP_dat, state_probabilities2, cutoff, feature_type_indices, seed, alpha)\n\n            generate_neighborhood(save_dir, numeric_dict, angle_dict, sin_cos_dict, np_data, index, seed, num_samples, selected_features, periodicity_upper, periodicity_lower)\n            state_probabilities3 = local_ns[\"run_model\"](model, np.load(save_dir + 'DATA_2/make_prediction.npy'))\n            TERP_dat = np.load(save_dir + 'DATA_2/TERP_dat.npy')\n            importance_0 = final_model(TERP_dat, state_probabilities3, unfaithfulness_threshold, feature_type_indices, selected_features, seed)\n            importance = make_result(feature_type_indices, indices_names, importance_0)\n            importance_master[index] = [transition, importance]\n            logger.info(\"Completed generating \" + str(point + 1) + \"/\" + str(len(points[transition])) + \" results!\" + \" First round features kept &gt;&gt;&gt; \" + str(len(selected_features)) + \", Final round features kept &gt;&gt;&gt; \" + str(np.nonzero(importance)[0].shape[0]))\n        logger.info(100*'_')\n\n    np.save(save_dir + 'MDTerp_feature_names.npy', indices_names)\n    with open(save_dir + 'MDTerp_results_all.pkl', 'wb') as f:\n        pickle.dump(importance_master, f)\n\n    logger.info(\"Feature names saved at &gt;&gt;&gt; \" + save_dir + 'MDTerp_feature_names.npy')\n    logger.info(\"All results saved at &gt;&gt;&gt; \" + save_dir + 'MDTerp_results_all.pkl')\n\n\n    shutil.rmtree(save_dir + 'DATA')\n    shutil.rmtree(save_dir + 'DATA_2')\n    logger.info(\"Completed!!!\")\n\n    # Flush and close logger\n    for handler in logger.handlers[:]:\n        handler.close()\n        logger.removeHandler(handler)\n</code></pre>"},{"location":"changelog/","title":"Changelog","text":""},{"location":"changelog/#v100-07312025","title":"v1.0.0 - 07/31/2025","text":"<p>Improvement:</p> <ul> <li>MDTerp published</li> </ul>"},{"location":"contributing/","title":"Contributing","text":"<p>Contributions are welcome, and they are greatly appreciated! Every little bit helps, and credit will always be given.</p> <p>You can contribute in many ways:</p>"},{"location":"contributing/#types-of-contributions","title":"Types of Contributions","text":""},{"location":"contributing/#report-bugs","title":"Report Bugs","text":"<p>Report bugs at https://github.com/shams-mehdi/MDTerp/issues.</p> <p>If you are reporting a bug, please include:</p> <ul> <li>Your operating system name and version.</li> <li>Any details about your local setup that might be helpful in troubleshooting.</li> <li>Detailed steps to reproduce the bug.</li> </ul>"},{"location":"contributing/#fix-bugs","title":"Fix Bugs","text":"<p>Look through the GitHub issues for bugs. Anything tagged with <code>bug</code> and <code>help wanted</code> is open to whoever wants to implement it.</p>"},{"location":"contributing/#implement-features","title":"Implement Features","text":"<p>Look through the GitHub issues for features. Anything tagged with <code>enhancement</code> and <code>help wanted</code> is open to whoever wants to implement it.</p>"},{"location":"contributing/#write-documentation","title":"Write Documentation","text":"<p>MDTerp could always use more documentation, whether as part of the official MDTerp docs, in docstrings, or even on the web in blog posts, articles, and such.</p>"},{"location":"contributing/#submit-feedback","title":"Submit Feedback","text":"<p>The best way to send feedback is to file an issue at https://github.com/shams-mehdi/MDTerp/issues.</p> <p>If you are proposing a feature:</p> <ul> <li>Explain in detail how it would work.</li> <li>Keep the scope as narrow as possible, to make it easier to implement.</li> <li>Remember that this is a volunteer-driven project, and that contributions are welcome :)</li> </ul>"},{"location":"contributing/#get-started","title":"Get Started!","text":"<p>Ready to contribute? Here's how to set up MDTerp for local development.</p> <ol> <li> <p>Fork the MDTerp repo on GitHub.</p> </li> <li> <p>Clone your fork locally:</p> <pre><code>$ git clone git@github.com:your_name_here/MDTerp.git\n</code></pre> </li> <li> <p>Install your local copy into a virtualenv. Assuming you have     virtualenvwrapper installed, this is how you set up your fork for     local development:</p> <pre><code>$ mkvirtualenv MDTerp\n$ cd MDTerp/\n$ python setup.py develop\n</code></pre> </li> <li> <p>Create a branch for local development:</p> <pre><code>$ git checkout -b name-of-your-bugfix-or-feature\n</code></pre> <p>Now you can make your changes locally.</p> </li> <li> <p>When you're done making changes, check that your changes pass flake8     and the tests, including testing other Python versions with tox:</p> <pre><code>$ flake8 MDTerp tests\n$ python setup.py test or pytest\n$ tox\n</code></pre> <p>To get flake8 and tox, just pip install them into your virtualenv.</p> </li> <li> <p>Commit your changes and push your branch to GitHub:</p> <pre><code>$ git add .\n$ git commit -m \"Your detailed description of your changes.\"\n$ git push origin name-of-your-bugfix-or-feature\n</code></pre> </li> <li> <p>Submit a pull request through the GitHub website.</p> </li> </ol>"},{"location":"contributing/#pull-request-guidelines","title":"Pull Request Guidelines","text":"<p>Before you submit a pull request, check that it meets these guidelines:</p> <ol> <li>The pull request should include tests.</li> <li>If the pull request adds functionality, the docs should be updated.     Put your new functionality into a function with a docstring, and add     the feature to the list in README.rst.</li> <li>The pull request should work for Python 3.8 and later, and     for PyPy. Check https://github.com/shams-mehdi/MDTerp/pull_requests and make sure that the tests pass for all     supported Python versions.</li> </ol>"},{"location":"faq/","title":"FAQ","text":""},{"location":"final_analysis/","title":"MDTerp module","text":"<p>MDTerp.final_analysis.py \u2013 Final MDTerp round for implementing forward feature selection and attributing feature importance.</p>"},{"location":"final_analysis/#MDTerp.final_analysis.SGDreg","title":"<code>SGDreg(data, labels, seed, alpha=1.0)</code>","text":"<p>Function for implementing linear regression using stochastic gradient descent.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>np.ndarray</code> <p>Numpy 2D array containing the similarity-weighted training data for the black-box model. Samples along rows and features along columns.</p> required <code>labels</code> <code>np.ndarray</code> <p>Numpy array containing metastable state prediction probabilities for a perturbed neighborhood corresponding to a specific sample. Includes the state for which the original sample has the highest probability.</p> required <code>seed</code> <code>int</code> <p>Random seed.</p> required <code>alpha</code> <code>float</code> <p>L2 norm of Ridge regression (Default: 1.0).</p> <code>1.0</code> <p>Returns:</p> Type Description <code>np.ndarray</code> <p>Numpy array with coefficients of all the features of the fitted linear model. float: Intercept of the fitted linear model.</p> Source code in <code>MDTerp/final_analysis.py</code> <pre><code>def SGDreg(data: np.ndarray, labels: np.ndarray, seed: int, alpha: float = 1.0) -&gt; Tuple[np.ndarray, float]:\n    \"\"\"\n    Function for implementing linear regression using stochastic gradient descent.\n\n    Args:\n        data (np.ndarray): Numpy 2D array containing the similarity-weighted training data for the black-box model. Samples along rows and features along columns.\n        labels (np.ndarray): Numpy array containing metastable state prediction probabilities for a perturbed neighborhood corresponding to a specific sample. Includes the state for which the original sample has the highest probability.\n        seed (int): Random seed.\n        alpha (float): L2 norm of Ridge regression (Default: 1.0).\n\n    Returns:\n        np.ndarray: Numpy array with coefficients of all the features of the fitted linear model.\n        float: Intercept of the fitted linear model.\n    \"\"\"\n    clf = Ridge(alpha, random_state = seed, solver = 'saga')\n    clf.fit(data,labels.ravel())\n    coefficients = clf.coef_\n    intercept = clf.intercept_\n    return coefficients, intercept\n</code></pre>"},{"location":"final_analysis/#MDTerp.final_analysis.charac_theta","title":"<code>charac_theta(d_U, d_S)</code>","text":"<p>Function for computing change in unfaithfulness per unit change in interpretation entropy as the number of features used to build a linear model increases by 1.</p> <p>Parameters:</p> Name Type Description Default <code>d_U</code> <code>np.ndarray</code> <p>Change in unfaithfulness with increasing features in linear models.</p> required <code>d_S</code> <code>np.ndarray</code> <p>Change in interpretation entropy with increasing features in linear models.</p> required <p>Returns:</p> Type Description <code>np.ndarray</code> <p>Change in unfaithfulness per unit change in interpretation entropy.</p> Source code in <code>MDTerp/final_analysis.py</code> <pre><code>def charac_theta(d_U: np.ndarray,d_S: np.ndarray) -&gt; np.ndarray:\n  \"\"\"\n    Function for computing change in unfaithfulness per unit change in interpretation entropy as the number of features used to build a linear model increases by 1.\n\n    Args:\n        d_U (np.ndarray): Change in unfaithfulness with increasing features in linear models.\n        d_S (np.ndarray): Change in interpretation entropy with increasing features in linear models.\n\n    Returns:\n        np.ndarray: Change in unfaithfulness per unit change in interpretation entropy.\n  \"\"\"\n  return -d_U/d_S\n</code></pre>"},{"location":"final_analysis/#MDTerp.final_analysis.final_model","title":"<code>final_model(neighborhood_data, pred_proba, unf_threshold, feature_type_indices, selected_features, seed)</code>","text":"<p>Function for computing final feature importance by implementing forward feature selection.</p> <p>Parameters:</p> Name Type Description Default <code>neighborhood_data</code> <code>np.ndarray</code> <p>Perturbed data generated by MDTerp.neighborhood.py.</p> required <code>pred_proba</code> <code>np.ndarray</code> <p>Metastable state probabilities obtained from the black-box.</p> required <code>unf_threshold</code> <code>float</code> <p>Hyperparameter setting a lower limit on model unfaithafulness. Forward feature selection ends when unfaithfulness reaches lower than this threshold.</p> required <code>feature_type_indices</code> <code>np.ndarray</code> <p>Indices of the features to perform the final round of MDTerp on.</p> required <code>seed</code> <code>int</code> <p>Random seed.</p> required <p>Returns:</p> Type Description <code>np.ndarray</code> <p>Normalized feature importance.</p> Source code in <code>MDTerp/final_analysis.py</code> <pre><code>def final_model(neighborhood_data: np.ndarray, pred_proba: np.ndarray, unf_threshold: float, feature_type_indices: np.ndarray, selected_features: np.ndarray, seed:int) -&gt; np.ndarray:\n    \"\"\"\n    Function for computing final feature importance by implementing forward feature selection.\n\n    Args:\n        neighborhood_data (np.ndarray): Perturbed data generated by MDTerp.neighborhood.py.\n        pred_proba (np.ndarray): Metastable state probabilities obtained from the black-box.\n        unf_threshold (float): Hyperparameter setting a lower limit on model unfaithafulness. Forward feature selection ends when unfaithfulness reaches lower than this threshold.\n        feature_type_indices (np.ndarray): Indices of the features to perform the final round of MDTerp on.\n        seed (int): Random seed.\n\n    Returns:\n        np.ndarray: Normalized feature importance.\n    \"\"\"\n    tot_feat = feature_type_indices[0].shape[0] + feature_type_indices[1].shape[0] + feature_type_indices[2].shape[0] + feature_type_indices[3].shape[0]\n    k_max = neighborhood_data.shape[1]\n\n    explain_class = np.argmax(pred_proba[0,:])\n\n    target = pred_proba[:,explain_class]\n\n    threshold, upper, lower = 0.5, 1, 0\n    target_binarized = np.where(target&gt;threshold, upper, lower)\n\n    clf = lda()\n    clf.fit(neighborhood_data,target_binarized)\n    projected_data = clf.transform(neighborhood_data)\n    weights = similarity_kernel(projected_data.reshape(-1,1), 1)\n\n    predict_proba = pred_proba[:,explain_class]\n    data = neighborhood_data*(weights**0.5).reshape(-1,1)\n    labels = target.reshape(-1,1)*(weights.reshape(-1,1)**0.5)\n\n    best_parameters_master = []\n    best_parameters_converted = []\n    best_unfaithfulness_master = []\n    best_interp_master = []\n\n    N = data.shape[1]\n    k_array = np.arange(1,k_max+1)\n\n    for k in k_array:\n      unfaithfulness_calc(k, N, data, predict_proba, best_parameters_master, labels, best_interp_master, best_parameters_converted, best_unfaithfulness_master, tot_feat, selected_features, seed)\n\n\n    optimal_k = 1\n\n\n    if N&lt;=3:\n      for i in range(1,N):\n        prime_model = -1\n        if best_unfaithfulness_master[i]&lt;=best_unfaithfulness_master[i-1] - unf_threshold:\n          prime_model = copy.deepcopy(i)-1\n          continue\n        else:\n          break\n\n    else:\n      charac_theta_mast = []\n\n      d_U_lst = []\n      d_S_lst = []\n      for i in range(1, len(selected_features)):\n        d_U_lst.append(best_unfaithfulness_master[i] - best_unfaithfulness_master[i-1])\n        d_S_lst.append(best_interp_master[i] - best_interp_master[i-1])\n\n      for i in range(len(selected_features)-1):\n        charac_theta_mast.append(charac_theta(d_U_lst[i], d_S_lst[i]))\n\n      range_theta_mast = []\n      for i in range(1,len(charac_theta_mast)):\n        range_theta_mast.append(np.array(charac_theta_mast)[i]-np.array(charac_theta_mast)[i-1])\n\n      prime_model = np.argmin(np.array(range_theta_mast))\n    return np.absolute(np.array(best_parameters_converted)[prime_model+1])\n</code></pre>"},{"location":"final_analysis/#MDTerp.final_analysis.interp","title":"<code>interp(coef_array)</code>","text":"<p>Function for computing interpretation entropy of the coefficients of a fitted linear model.</p> <p>Parameters:</p> Name Type Description Default <code>coef_array</code> <code>np.ndarray</code> <p>Numpy array with coefficients of all the features of the fitted linear model.</p> required <p>Returns:</p> Type Description <code>float</code> <p>Interpretation entropy of the coefficients of a fitted linear model.</p> Source code in <code>MDTerp/final_analysis.py</code> <pre><code>def interp(coef_array: np.ndarray) -&gt; float:\n  \"\"\"\n    Function for computing interpretation entropy of the coefficients of a fitted linear model.\n\n    Args:\n        coef_array (np.ndarray): Numpy array with coefficients of all the features of the fitted linear model.\n\n    Returns:\n        float: Interpretation entropy of the coefficients of a fitted linear model.\n  \"\"\"\n  a = np.absolute(coef_array)/np.sum(np.absolute(coef_array))\n  t = 0\n  for i in range(a.shape[0]):\n    if a[i]==0:\n      continue\n    else:\n      t += a[i]*np.log(a[i])\n  return -t/np.log(coef_array.shape[0])\n</code></pre>"},{"location":"final_analysis/#MDTerp.final_analysis.similarity_kernel","title":"<code>similarity_kernel(data, kernel_width=1.0)</code>","text":"<p>Function for computing similarity\u2208[0,1] of a perturbed sample with respect to the original sample using LDA transformed distance.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>np.ndarray</code> <p>LDA transformed data.</p> required <code>kernel_width</code> <code>float</code> <p>Width of the similarity kernel (Default: 1.0).</p> <code>1.0</code> <p>Returns:</p> Type Description <code>np.ndarray</code> <p>Similarity\u2208[0,1] of neighborhood.</p> Source code in <code>MDTerp/final_analysis.py</code> <pre><code>def similarity_kernel(data: np.ndarray, kernel_width: float = 1.0) -&gt; np.ndarray:\n    \"\"\"\n    Function for computing similarity\u2208[0,1] of a perturbed sample with respect to the original sample using LDA transformed distance.\n\n    Args:\n        data (np.ndarray): LDA transformed data.\n        kernel_width (float): Width of the similarity kernel (Default: 1.0).\n\n    Returns:\n        np.ndarray: Similarity\u2208[0,1] of neighborhood.\n    \"\"\"\n    distances = met.pairwise_distances(data,data[0].reshape(1, -1),metric='euclidean').ravel()\n    return np.sqrt(np.exp(-(distances ** 2) / kernel_width ** 2))\n</code></pre>"},{"location":"final_analysis/#MDTerp.final_analysis.unfaithfulness_calc","title":"<code>unfaithfulness_calc(k, N, data, predict_proba, best_parameters_master, labels, best_interp_master, best_parameters_converted, best_unfaithfulness_master, tot_feat, selected_features, seed)</code>","text":"<p>Function for implementing linear regression using stochastic gradient descent.</p> <p>Parameters:</p> Name Type Description Default <code>k</code> <code>int</code> <p>Number of features for building a surrogate, local, linear model.</p> required <code>N</code> <code>int</code> <p>Number of features selected for detailed analysis.</p> required <code>data</code> <code>np.ndarray</code> <p>Numpy 2D array containing the similarity-weighted training data for the black-box model. Samples along rows and features along columns.</p> required <code>predict_proba</code> <code>np.ndarray</code> <p>Numpy array containing metastable state prediction probabilities for a perturbed neighborhood corresponding to a specific sample. Includes the state for which the original sample has the highest probability.</p> required <code>best_parameters_master</code> <code>list</code> <p>List of lists that saves the best fit coefficients for linear models built using k=1, .., N features.</p> required <code>best_interp_master</code> <code>list</code> <p>List that saves the interpretation entropy for the linear models built using k=1,...,N features.</p> required <code>best_parameters_converted</code> <code>list</code> <p>List of lists that saves the best fit coefficients for linear models built using k=1, .., N features, and imputes the discarded features in the initial MDTerp round with 0 importance to preserve feature ID.</p> required <code>best_unfaithfulness_master</code> <code>list</code> <p>List that saves the unfaithfulness of the best-fit linear models built using k=1, ..., N features.</p> required <code>tot_feat</code> <code>int</code> <p>Total number of features in the dataset.</p> required <code>selected_features</code> <code>np.ndarray</code> <p>Indices of the features selected for detailed MDTerp analysis.</p> required <code>seed</code> <code>int</code> <p>Random seed.</p> required <p>Returns:</p> Type Description <code>None</code> <p>None</p> Source code in <code>MDTerp/final_analysis.py</code> <pre><code>def unfaithfulness_calc(k: int, N: int, data: np.ndarray, predict_proba: np.ndarray, best_parameters_master: list, labels: np.ndarray, best_interp_master: list, best_parameters_converted: list, best_unfaithfulness_master: list, tot_feat: int, selected_features: np.ndarray, seed: int) -&gt; None:\n  \"\"\"\n    Function for implementing linear regression using stochastic gradient descent.\n\n    Args:\n        k (int): Number of features for building a surrogate, local, linear model.\n        N (int): Number of features selected for detailed analysis.\n        data (np.ndarray): Numpy 2D array containing the similarity-weighted training data for the black-box model. Samples along rows and features along columns.\n        predict_proba (np.ndarray): Numpy array containing metastable state prediction probabilities for a perturbed neighborhood corresponding to a specific sample. Includes the state for which the original sample has the highest probability.\n        best_parameters_master (list): List of lists that saves the best fit coefficients for linear models built using k=1, .., N features.\n        best_interp_master (list): List that saves the interpretation entropy for the linear models built using k=1,...,N features.\n        best_parameters_converted (list): List of lists that saves the best fit coefficients for linear models built using k=1, .., N features, and imputes the discarded features in the initial MDTerp round with 0 importance to preserve feature ID.\n        best_unfaithfulness_master (list): List that saves the unfaithfulness of the best-fit linear models built using k=1, ..., N features.\n        tot_feat (int): Total number of features in the dataset.\n        selected_features (np.ndarray): Indices of the features selected for detailed MDTerp analysis.\n        seed (int): Random seed.\n\n    Returns:\n        None\n  \"\"\" \n  models = []\n  TERP_SGD_parameters = []\n  TERP_SGD_unfaithfulness = []\n  TERP_SGD_interp = []\n  if k == 1:\n    inherited_nonzero = np.array([],dtype=int)\n    inherited_zero = np.arange(N)\n\n  elif k &gt; 1:\n    inherited_nonzero = np.nonzero(best_parameters_master[k-2][:-1])[0]\n    inherited_zero = np.where(best_parameters_master[k-2][:-1] == 0)[0]\n\n  for i in range(N-k+1):\n    models.append(np.append(inherited_nonzero, inherited_zero[i]))\n    result_a, result_b = SGDreg(data[:,models[i]], labels, seed)\n    parameters = np.zeros((N+1))\n    parameters[models[i]] = result_a\n    parameters[-1] = result_b\n    TERP_SGD_parameters.append(parameters)\n    residual = np.corrcoef(labels[:,0],(np.column_stack((data, np.ones((data.shape[0]))))@parameters[:]).reshape(-1,1)[:,0])[0,1]\n    TERP_SGD_unfaithfulness.append(1-np.absolute(residual))\n    TERP_SGD_interp.append(interp(TERP_SGD_parameters[-1][:-1]))\n    TERP_SGD_IFE = np.array(TERP_SGD_unfaithfulness)\n\n  best_model = np.argsort(TERP_SGD_IFE)[0]\n  best_parameters_master.append(TERP_SGD_parameters[best_model])\n  best_interp_master.append(TERP_SGD_interp[best_model])\n\n  temp_coef_1 = TERP_SGD_parameters[best_model][:-1]\n  temp_coef_2 = np.zeros((tot_feat))\n  temp_coef_2[selected_features] = copy.deepcopy(temp_coef_1)\n  best_parameters_converted.append(temp_coef_2)\n  best_unfaithfulness_master.append(TERP_SGD_unfaithfulness[best_model])\n\n  surrogate_pred = data@TERP_SGD_parameters[best_model][:-1]\n</code></pre>"},{"location":"final_analysis/#MDTerp.final_analysis.zeta","title":"<code>zeta(U, S, theta)</code>","text":"<p>Function for computing the interpretation free energy.</p> <p>Parameters:</p> Name Type Description Default <code>U</code> <code>np.ndarray</code> <p>Numpy array with unfaithfulness of the best models for number of features, k = 1, ..., N.</p> required <code>S</code> <code>np.ndarray</code> <p>Numpy array with interpretation entropy of the best models for number of features, k = 1, ..., N.</p> required <code>theta</code> <code>float</code> <p>Temperature of the fitted linear model.</p> required <p>Returns:</p> Type Description <code>np.ndarray</code> <p>Interpretation free energy.</p> Source code in <code>MDTerp/final_analysis.py</code> <pre><code>def zeta(U: np.ndarray,S: np.ndarray,theta: float) -&gt; np.ndarray:\n  \"\"\"\n    Function for computing the interpretation free energy.\n\n    Args:\n        U (np.ndarray): Numpy array with unfaithfulness of the best models for number of features, k = 1, ..., N.\n        S (np.ndarray): Numpy array with interpretation entropy of the best models for number of features, k = 1, ..., N.\n        theta (float): Temperature of the fitted linear model.\n\n    Returns:\n        np.ndarray: Interpretation free energy.\n  \"\"\"\n  return U + theta*S\n</code></pre>"},{"location":"init_analysis/","title":"MDTerp module","text":"<p>MDTerp.init_analysis.py \u2013 Initial MDTerp round for discarding irrelevant features from analysis for the forward feature selection in MDTerp.final_analysis.py.</p>"},{"location":"init_analysis/#MDTerp.init_analysis.SGDreg","title":"<code>SGDreg(data, labels, seed, alpha)</code>","text":"<p>Function for implementing linear regression using stochastic gradient descent.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>np.ndarray</code> <p>Numpy 2D array containing the similarity-weighted training data for the black-box model. Samples along rows and features along columns.</p> required <code>labels</code> <code>np.ndarray</code> <p>Numpy array containing metastable state prediction probabilities for a perturbed neighborhood corresponding to a specific sample. Includes the state for which the original sample has the highest probability.</p> required <code>seed</code> <code>int</code> <p>Random seed.</p> required <code>alpha</code> <code>float</code> <p>L2 norm of Ridge regression.</p> required <p>Returns:</p> Type Description <code>np.ndarray</code> <p>Numpy array with coefficients of all the features of the fitted linear model. float: Intercept of the fitted linear model.</p> Source code in <code>MDTerp/init_analysis.py</code> <pre><code>def SGDreg(data: np.ndarray, labels: np.ndarray, seed: int, alpha: float) -&gt; Tuple[np.ndarray, float]:\n    \"\"\"\n    Function for implementing linear regression using stochastic gradient descent.\n\n    Args:\n        data (np.ndarray): Numpy 2D array containing the similarity-weighted training data for the black-box model. Samples along rows and features along columns.\n        labels (np.ndarray): Numpy array containing metastable state prediction probabilities for a perturbed neighborhood corresponding to a specific sample. Includes the state for which the original sample has the highest probability.\n        seed (int): Random seed.\n        alpha (float): L2 norm of Ridge regression.\n\n    Returns:\n        np.ndarray: Numpy array with coefficients of all the features of the fitted linear model.\n        float: Intercept of the fitted linear model.\n    \"\"\"\n    clf = Ridge(alpha, random_state = seed, solver = 'saga')\n    clf.fit(data,labels.ravel())\n    coefficients = clf.coef_\n    intercept = clf.intercept_\n    return coefficients, intercept\n</code></pre>"},{"location":"init_analysis/#MDTerp.init_analysis.init_model","title":"<code>init_model(neighborhood_data, pred_proba, cutoff, given_indices, seed, alpha)</code>","text":"<p>Function for fitting the initial linear model for discarding irrelevant features and choosing promising features for detailed analysis.</p> <p>Parameters:</p> Name Type Description Default <code>neighborhood_data</code> <code>np.ndarray</code> <p>Perturbed data generated by MDTerp.neighborhood.py.</p> required <code>pred_proba</code> <code>np.ndarray</code> <p>Metastable state probabilities obtained from the black-box.</p> required <code>cutoff</code> <code>int</code> <p>Maximum number of features kept for the final round of MDTerp and forward feature selection (use to improve compute time: when too many features are in the dataset and a priori it is known it is unlikely that more features than set by cutoff will be relevant).</p> required <code>given_indices</code> <code>np.ndarray</code> <p>Indices of the features to perform this (first) round of MDTerp on.</p> required <code>seed</code> <code>int</code> <p>Random seed.</p> required <p>Returns:</p> Type Description <code>np.ndarray</code> <p>List of three lists containing indices of the selected numeric, angular, sine/cosine features for further analysis/forward feature selection.</p> Source code in <code>MDTerp/init_analysis.py</code> <pre><code>def init_model(neighborhood_data: np.ndarray, pred_proba: np.ndarray, cutoff: int, given_indices: np.ndarray, seed: int, alpha: float) -&gt; list:\n    \"\"\"\n    Function for fitting the initial linear model for discarding irrelevant features and choosing promising features for detailed analysis.\n\n    Args:\n        neighborhood_data (np.ndarray): Perturbed data generated by MDTerp.neighborhood.py.\n        pred_proba (np.ndarray): Metastable state probabilities obtained from the black-box.\n        cutoff (int): Maximum number of features kept for the final round of MDTerp and forward feature selection (use to improve compute time: when too many features are in the dataset and a priori it is known it is unlikely that more features than set by cutoff will be relevant).\n        given_indices (np.ndarray): Indices of the features to perform this (first) round of MDTerp on.\n        seed (int): Random seed.\n\n    Returns:\n        np.ndarray: List of three lists containing indices of the selected numeric, angular, sine/cosine features for further analysis/forward feature selection.\n    \"\"\"\n    explain_class = np.argmax(pred_proba[0,:])\n\n    target = pred_proba[:,explain_class]\n\n    threshold, upper, lower = 0.5, 1, 0\n    target_binarized = np.where(target&gt;threshold, upper, lower)\n\n    clf = lda()\n    clf.fit(neighborhood_data,target_binarized)\n    projected_data = clf.transform(neighborhood_data)\n    weights = similarity_kernel(projected_data.reshape(-1,1), 1)\n\n\n    predict_proba = pred_proba[:,explain_class]\n    data = neighborhood_data*(weights**0.5).reshape(-1,1)\n    labels = target.reshape(-1,1)*(weights.reshape(-1,1)**0.5)\n\n    coefficients_selection, intercept_selection = SGDreg(data, labels, seed, alpha)\n    selected_features = np.argsort(np.absolute(coefficients_selection))[::-1][:cutoff]\n\n    return selected_features\n</code></pre>"},{"location":"init_analysis/#MDTerp.init_analysis.similarity_kernel","title":"<code>similarity_kernel(data, kernel_width=1.0)</code>","text":"<p>Function for computing similarity\u2208[0,1] of a perturbed sample with respect to the original sample using LDA transformed distance.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>np.ndarray</code> <p>LDA transformed data.</p> required <code>kernel_width</code> <code>float</code> <p>Width of the similarity kernel (Default: 1.0). Since LDA was used for dimensionality reduction, no need to tune this hyperparameter.</p> <code>1.0</code> <p>Returns:</p> Type Description <code>np.ndarray</code> <p>Similarity\u2208[0,1] of neighborhood.</p> Source code in <code>MDTerp/init_analysis.py</code> <pre><code>def similarity_kernel(data: np.ndarray, kernel_width: float = 1.0) -&gt; np.ndarray:\n    \"\"\"\n    Function for computing similarity\u2208[0,1] of a perturbed sample with respect to the original sample using LDA transformed distance.\n\n    Args:\n        data (np.ndarray): LDA transformed data.\n        kernel_width (float): Width of the similarity kernel (Default: 1.0). Since LDA was used for dimensionality reduction, no need to tune this hyperparameter.\n\n    Returns:\n        np.ndarray: Similarity\u2208[0,1] of neighborhood.\n    \"\"\"\n    distances = met.pairwise_distances(data,data[0].reshape(1, -1),metric='euclidean').ravel()\n    return np.sqrt(np.exp(-(distances ** 2) / kernel_width ** 2))\n</code></pre>"},{"location":"installation/","title":"Installation","text":""},{"location":"installation/#stable-release","title":"Stable release","text":"<p>To install MDTerp, run this command in your terminal:</p> <pre><code>pip install MDTerp\n</code></pre> <p>This is the preferred method to install MDTerp, as it will always install the most recent stable release.</p> <p>If you don't have pip installed, this Python installation guide can guide you through the process.</p>"},{"location":"installation/#from-sources","title":"From sources","text":"<p>To install MDTerp from sources, run this command in your terminal:</p> <pre><code>pip install git+https://github.com/shams-mehdi/MDTerp\n</code></pre>"},{"location":"neighborhood/","title":"MDTerp module","text":"<p>MDTerp.neighborhood.py \u2013 Function for generating perturbed neighborhood samples.</p>"},{"location":"neighborhood/#MDTerp.neighborhood.generate_neighborhood","title":"<code>generate_neighborhood(save_dir, numeric_dict, angle_dict, sin_cos_dict, np_dat, index, seed, num_samples, selected_features, periodicity_upper=3.141592653589793, periodicity_lower=-3.141592653589793)</code>","text":"<p>Function for creating a logger detailing MDTerp operations.</p> <p>Parameters:</p> Name Type Description Default <code>save_dir</code> <code>str</code> <p>Location to save MDTerp results.</p> required <code>numeric_dict</code> <code>dict</code> <p>Python dictionary, each key represents the name of a numeric feature (non-periodic). Values should be lists with a single element using the index of the corresponding numpy array in np_data.</p> required <code>angle_dict</code> <code>dict</code> <p>Python dictionary, each key represents the name of an angular feature in [-pi, pi]. Values should be lists with a single element using the index of the corresponding numpy array in np_data.</p> required <code>sin_cos_dict</code> <code>dict</code> <p>Python dictionary, each key represents the name of an angular feature. Values should be lists with two elements representing the sine, cosine indices of the corresponding numpy array in np_data.</p> required <code>np_dat</code> <code>np.ndarray</code> <p>Numpy 2D array containing training data for the black-box model. Samples along rows and features along columns.</p> required <code>index</code> <code>int</code> <p>Row/sample of the provided dataset using np_dat to analyze.</p> required <code>seed</code> <code>int</code> <p>Random seed.</p> required <code>num_samples</code> <code>int</code> <p>Size of the generated perturbed neighborhood.</p> required <code>selected_features</code> <code>&lt;built-in function array&gt;</code> <p>If an empty array (Default), perturbs all the features/columns. Otherwise, an array of integers representing the subset of features to perturb.</p> required <code>periodicity_upper</code> <code>float</code> <p>Sets periodicity of the angular features (Default: numpy.pi).</p> <code>3.141592653589793</code> <code>periodicity_lower</code> <code>float</code> <p>Sets periodicity of the angular features (Default: -numpy.py).</p> <code>-3.141592653589793</code> <p>Returns:</p> Type Description <code>list</code> <p>List of np.ndarray indicating indices of numeric, angular, sin_cos features respectively. list: List of the combined names of the features.</p> Source code in <code>MDTerp/neighborhood.py</code> <pre><code>def generate_neighborhood(save_dir: str, numeric_dict: dict, angle_dict: dict, sin_cos_dict: dict, np_dat: np.ndarray, index: int, seed: int, num_samples: int, selected_features: np.array, periodicity_upper: float = np.pi, periodicity_lower: float = -np.pi):\n    \"\"\"\n    Function for creating a logger detailing MDTerp operations.\n\n    Args:\n        save_dir (str): Location to save MDTerp results.\n        numeric_dict (dict): Python dictionary, each key represents the name of a numeric feature (non-periodic). Values should be lists with a single element using the index of the corresponding numpy array in np_data.\n        angle_dict (dict): Python dictionary, each key represents the name of an angular feature in [-pi, pi]. Values should be lists with a single element using the index of the corresponding numpy array in np_data.\n        sin_cos_dict (dict): Python dictionary, each key represents the name of an angular feature. Values should be lists with two elements representing the sine, cosine indices of the corresponding numpy array in np_data.\n        np_dat (np.ndarray): Numpy 2D array containing training data for the black-box model. Samples along rows and features along columns.\n        index (int): Row/sample of the provided dataset using np_dat to analyze.\n        seed (int): Random seed.\n        num_samples (int): Size of the generated perturbed neighborhood.\n        selected_features: If an empty array (Default), perturbs all the features/columns. Otherwise, an array of integers representing the subset of features to perturb.\n        periodicity_upper (float): Sets periodicity of the angular features (Default: numpy.pi).\n        periodicity_lower (float): Sets periodicity of the angular features (Default: -numpy.py).\n    Returns:\n        list: List of np.ndarray indicating indices of numeric, angular, sin_cos features respectively.\n        list: List of the combined names of the features.\n    \"\"\"\n\n    numeric_indices = []\n    angle_indices = []\n    sin_indices = []\n    cos_indices = []\n\n    indices_names = []\n\n    for i in numeric_dict:\n            numeric_indices.append(numeric_dict[i])\n            indices_names.append(i)\n            assert numeric_dict[i][0] in np.arange(np_dat.shape[1]), 'Invalid numeric index'\n    for i in angle_dict:\n            angle_indices.append(angle_dict[i])\n            indices_names.append(i)\n            assert angle_dict[i][0] in np.arange(np_dat.shape[1]), 'Invalid angle index'\n    for i in sin_cos_dict:\n            sin_indices.append(sin_cos_dict[i][0])\n            cos_indices.append(sin_cos_dict[i][1])\n            indices_names.append(i)\n            assert sin_cos_dict[i][0] in np.arange(np_dat.shape[1]), 'Invalid sin index'\n            assert sin_cos_dict[i][1] in np.arange(np_dat.shape[1]), 'Invalid cos index'\n\n    numeric_indices = np.array(numeric_indices).flatten()\n    angle_indices = np.array(angle_indices).flatten()\n    sin_indices = np.array(sin_indices).flatten()\n    cos_indices = np.array(cos_indices).flatten()\n\n    std_master = []\n    for i in range(np_dat.shape[1]):\n        if i not in angle_indices:\n            std_master.append(np.std(np_dat[:,i]))\n        else:\n            std_master.append(sst.circstd(np_dat[:,i], high = np.pi, low = -np.pi))\n\n    std_master = np.array(std_master).flatten()\n    if selected_features.shape[0]==0:\n        save_directory = save_dir + 'DATA'\n        os.makedirs(save_directory, exist_ok = True)\n        make_prediction_data, TERP_data = perturbation(np_dat, std_master, num_samples, index, seed)\n    else:\n        save_directory = save_dir + 'DATA_2'\n        os.makedirs(save_directory, exist_ok = True)\n        make_prediction_trimmed, TERP_data = perturbation(np_dat[:, selected_features], std_master[selected_features], num_samples, index, seed)\n        make_prediction_data = np.ones((num_samples, np_dat.shape[1]))*np_dat[index,:]\n        make_prediction_data[:, selected_features] = make_prediction_trimmed\n\n    np.save(save_directory + '/make_prediction.npy', make_prediction_data)  \n    np.save(save_directory + '/TERP_dat.npy', TERP_data)\n\n    return [numeric_indices, angle_indices, sin_indices, cos_indices], indices_names\n</code></pre>"},{"location":"neighborhood/#MDTerp.neighborhood.perturbation","title":"<code>perturbation(data, std, num_samples, index, seed)</code>","text":"<p>Function for generating perturbed samples.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>np.ndarray</code> <p>Numpy 2D array containing training data for the black-box model. Samples along rows and features along columns.</p> required <code>std</code> <code>np.ndarray</code> <p>Numpy 1D array containing the standard deviation of features in data.</p> required <code>num_samples</code> <code>int</code> <p>Size of the generated perturbed neighborhood.</p> required <code>index</code> <code>int</code> <p>Row/sample of the provided dataset using np_dat to analyze.</p> required <code>seed</code> <code>int</code> <p>Random seed.</p> required <p>Returns:</p> Type Description <code>np.ndarray</code> <p>Perturbed samples to be passed to the black-box model to fetch state probabilities. np.ndarray: Perturbed samples for constructing linear models.</p> Source code in <code>MDTerp/neighborhood.py</code> <pre><code>def perturbation(data: np.ndarray, std: np.ndarray, num_samples: float, index: int, seed: int):\n      \"\"\"\n      Function for generating perturbed samples.\n\n      Args:\n        data (np.ndarray): Numpy 2D array containing training data for the black-box model. Samples along rows and features along columns.\n        std (np.ndarray): Numpy 1D array containing the standard deviation of features in data.\n        num_samples (int): Size of the generated perturbed neighborhood.\n        index (int): Row/sample of the provided dataset using np_dat to analyze.\n        seed (int): Random seed.\n      Returns:\n        np.ndarray: Perturbed samples to be passed to the black-box model to fetch state probabilities.\n        np.ndarray: Perturbed samples for constructing linear models.\n      \"\"\"\n      make_prediction_data = np.zeros((num_samples, data.shape[1]))\n      TERP_data = np.zeros((num_samples, data.shape[1]))\n\n      perturb = np.random.randint(0, 2, num_samples * data.shape[1]).reshape((num_samples, data.shape[1]))\n      perturb[0,:] = 1\n\n      np.random.seed(seed)\n\n      for i in range(num_samples):\n        for j in range(data.shape[1]):\n          if perturb[i,j] == 1:\n            make_prediction_data[i,j] = data[index,j]\n          elif perturb[i,j] == 0:\n            rand_data = np.random.normal(0, 1)\n            make_prediction_data[i,j] = data[index,j] + std[j]*rand_data\n            TERP_data[i,j] = rand_data\n\n      return make_prediction_data, TERP_data\n</code></pre>"},{"location":"usage/","title":"Usage","text":"<p>To use MDTerp in a project:</p> <pre><code>import MDTerp\n</code></pre> <p>Go to https://shams-mehdi.github.io/MDTerp/MDTerp_demo1.ipynb, https://shams-mehdi.github.io/MDTerp/MDTerp_demo2.ipynb for explicit usage.</p>"},{"location":"utils/","title":"MDTerp module","text":"<p>MDTerp.utils.py \u2013 Auxiliary utility functions for MDTerp package.</p>"},{"location":"utils/#MDTerp.utils.dominant_feature","title":"<code>dominant_feature(all_result_loc, n=0)</code>","text":"<p>Function summarizing MDTerp results for all the transitions present in the dataset.</p> <p>Parameters:</p> Name Type Description Default <code>all_results_loc</code> <code>str</code> <p>Location to save MDTerp results.</p> required <code>importance_coverage</code> <code>float</code> <p>For a specific transition, sets a cutoff for the sum of the most important features in descending order.</p> required <p>Returns:</p> Type Description <code>dict</code> <p>Dictionary with keys representing detected transitions. E.g., key '3_8' means transition between index 3 and index 8 according to the prob array. Values are lists representing feature importance using the length of the list equaling the number of features in the provided dataset.</p> Source code in <code>MDTerp/utils.py</code> <pre><code>def dominant_feature(all_result_loc: str, n: int = 0) -&gt; dict:\n    \"\"\"\n    Function summarizing MDTerp results for all the transitions present in the dataset.\n\n    Args:\n        all_results_loc (str): Location to save MDTerp results.\n        importance_coverage (float): For a specific transition, sets a cutoff for the sum of the most important features in descending order.\n\n    Returns:\n        dict: Dictionary with keys representing detected transitions. E.g., key '3_8' means transition between index 3 and index 8 according to the prob array. Values are lists representing feature importance using the length of the list equaling the number of features in the provided dataset.\n    \"\"\"\n    with open(all_result_loc, 'rb') as f:\n        loaded_dict = pickle.load(f)  \n\n    for ii in loaded_dict:\n        tmp_c = loaded_dict[ii][1]\n        loaded_dict[ii] = np.argsort(tmp_c)[::-1][n]\n\n    return loaded_dict\n</code></pre>"},{"location":"utils/#MDTerp.utils.input_summary","title":"<code>input_summary(logger, numeric_dict, angle_dict, sin_cos_dict, save_dir, np_data)</code>","text":"<p>Function for summarizing user-provided input data in Python Logger.</p> <p>Parameters:</p> Name Type Description Default <code>logger</code> <code>Logger</code> <p>Logger object created using Python's built-in logging module.</p> required <code>numeric_dict</code> <code>dict</code> <p>Python dictionary, each key represents the name of a numeric feature (non-periodic). Values should be lists with a single element using the index of the corresponding numpy array in np_data.</p> required <code>angle_dict</code> <code>dict</code> <p>Python dictionary, each key represents the name of an angular feature in [-pi, pi]. Values should be lists with a single element with the index of the corresponding numpy array in np_data.</p> required <code>sin_cos_dict</code> <code>dict</code> <p>Python dictionary, each key represents the name of an angular feature. Values should be lists with two elements using the sine, cosine indices of the corresponding numpy array in np_data.</p> required <code>save_dir</code> <code>str</code> <p>Location to save MDTerp results.</p> required <code>np_data</code> <code>np.ndarray</code> <p>Numpy 2D array containing training data for the black-box model. Samples along rows and features along columns.</p> required <p>Returns:</p> Type Description <code>None</code> <p>None</p> Source code in <code>MDTerp/utils.py</code> <pre><code>def input_summary(logger: Logger, numeric_dict: dict, angle_dict: dict, sin_cos_dict: dict, save_dir: str, np_data: np.ndarray) -&gt; None:\n    \"\"\"\n    Function for summarizing user-provided input data in Python Logger.\n\n    Args:\n        logger (Logger): Logger object created using Python's built-in logging module.\n        numeric_dict (dict): Python dictionary, each key represents the name of a numeric feature (non-periodic). Values should be lists with a single element using the index of the corresponding numpy array in np_data.\n        angle_dict (dict): Python dictionary, each key represents the name of an angular feature in [-pi, pi]. Values should be lists with a single element with the index of the corresponding numpy array in np_data.\n        sin_cos_dict (dict): Python dictionary, each key represents the name of an angular feature. Values should be lists with two elements using the sine, cosine indices of the corresponding numpy array in np_data.\n        save_dir (str): Location to save MDTerp results.\n        np_data (np.ndarray): Numpy 2D array containing training data for the black-box model. Samples along rows and features along columns.\n\n    Returns:\n        None\n    \"\"\"\n    logger.info('MDTerp result location &gt;&gt;&gt; ' + save_dir )\n    logger.info('Defined numeric features &gt;&gt;&gt; ' + str(len(list(numeric_dict.keys()))) )\n    logger.info('Defined angle features &gt;&gt;&gt; ' + str(len(list(angle_dict.keys()))) )\n    logger.info('Defined sin_cos features &gt;&gt;&gt; ' + str(len(list(sin_cos_dict.keys()))) )\n    logger.info('Number of samples in blackbox model training data &gt;&gt;&gt; ' + str(np_data.shape[0]) )\n    logger.info('Number of columns in blackbox model training data &gt;&gt;&gt; ' + str(np_data.shape[1]) )\n    if np_data.shape[1] != len(list(numeric_dict.keys())) + len(list(angle_dict.keys())) + len(list(sin_cos_dict.keys()))*2:\n        logger.error('Assertion failure between provided feature dictionaries and input data!')\n        raise ValueError('Assertion failure between provided feature dictionaries and input data!')\n\n    logger.info(100*'-')\n</code></pre>"},{"location":"utils/#MDTerp.utils.log_maker","title":"<code>log_maker(save_dir)</code>","text":"<p>Function for creating a logger detailing MDTerp operations.</p> <p>Parameters:</p> Name Type Description Default <code>save_dir</code> <code>str</code> <p>Location to save MDTerp results.</p> required <p>Returns:</p> Type Description <code>Logger</code> <p>Logger object created using Python's built-in logging module.</p> Source code in <code>MDTerp/utils.py</code> <pre><code>def log_maker(save_dir: str) -&gt; Logger:\n    \"\"\"\n    Function for creating a logger detailing MDTerp operations.\n\n    Args:\n        save_dir (str): Location to save MDTerp results.\n\n    Returns:\n        Logger: Logger object created using Python's built-in logging module.\n    \"\"\"\n    fmt = '%(asctime)s %(name)-15s %(levelname)-8s %(message)s'\n    datefmt='%m-%d-%y %H:%M:%S'\n    logging.basicConfig(level=logging.INFO,format=fmt,datefmt=datefmt,filename=save_dir+'/MDTerp_summary.log',filemode='w')\n    logger = logging.getLogger('initialization')\n    console_handler = logging.StreamHandler()\n    console_handler.setLevel(logging.INFO)\n    formatter = logging.Formatter(fmt,datefmt=datefmt)\n    console_handler.setFormatter(formatter)\n    logger.addHandler(console_handler)\n    logger.info(100*'-')\n    logger.info('Starting MDTerp...')\n    logger.info(100*'-')\n\n    return logger\n</code></pre>"},{"location":"utils/#MDTerp.utils.picker_fn","title":"<code>picker_fn(prob, threshold, point_max)</code>","text":"<p>Function for picking points at the transition state ensemble. Uses provided data and metastable state probability from the black-box model.</p> <p>Parameters:</p> Name Type Description Default <code>prob</code> <code>np.ndarray</code> <p>Numpy 2D array containing metastable state prediction probabilities from the black-box model. Rows represent samples, and the number of columns represents the number of states. Each row should sum to 1.</p> required <code>threshold</code> <code>float</code> <p>Threshold for identifying if a sample belongs to a transition state predicted by the black-box model. If the metastable state probability &gt; threshold for two different classes for a specific sample, it's suitable for analysis.</p> required <code>point_max</code> <code>int</code> <p>If too many suitable points exist for a specific transition (e.g., transition between metastable state 3 and 8), point_max sets the maximum number of points chosen for analysis. Points are chosen from a uniform distribution.</p> required <p>Returns:</p> Type Description <code>dict</code> <p>Dictionary with keys representing detected transitions. E.g., key '3_8' means transition between index 3 and index 8 according to the prob array. Values represent chosen samples/rows in the provided dataset undergoing this transition.</p> Source code in <code>MDTerp/utils.py</code> <pre><code>def picker_fn(prob: np.ndarray, threshold: float, point_max: int) -&gt; dict:\n    \"\"\"\n    Function for picking points at the transition state ensemble. Uses provided data and metastable state probability from the black-box model.\n\n    Args:\n        prob (np.ndarray): Numpy 2D array containing metastable state prediction probabilities from the black-box model. Rows represent samples, and the number of columns represents the number of states. Each row should sum to 1.\n        threshold (float): Threshold for identifying if a sample belongs to a transition state predicted by the black-box model. If the metastable state probability &gt; threshold for two different classes for a specific sample, it's suitable for analysis.\n        point_max (int): If too many suitable points exist for a specific transition (e.g., transition between metastable state 3 and 8), point_max sets the maximum number of points chosen for analysis. Points are chosen from a uniform distribution.\n\n    Returns:\n        dict: Dictionary with keys representing detected transitions. E.g., key '3_8' means transition between index 3 and index 8 according to the prob array. Values represent chosen samples/rows in the provided dataset undergoing this transition.\n    \"\"\"\n    transition_dict = defaultdict(list)\n    for i in range(prob.shape[0]):\n        sorted_ind = np.sort(np.argsort(prob[i, :])[::-1][:2])\n        sorted_val = np.sort(prob[i, :])[::-1][:2]\n        if (sorted_val[0]&gt;=threshold) and (sorted_val[1]&gt;=threshold):\n            transition_dict[str(sorted_ind[0]) + '_' + str(sorted_ind[1])].append(i)\n    for i in transition_dict.keys():\n        transition_dict[i] = np.random.choice(transition_dict[i], size = min(point_max, len(transition_dict[i])), replace = False)\n\n    return transition_dict\n</code></pre>"},{"location":"utils/#MDTerp.utils.transition_summary","title":"<code>transition_summary(all_result_loc, importance_coverage=0.8)</code>","text":"<p>Function summarizing MDTerp results for all the transitions present in the dataset.</p> <p>Parameters:</p> Name Type Description Default <code>all_results_loc</code> <code>str</code> <p>Location to save MDTerp results.</p> required <code>importance_coverage</code> <code>float</code> <p>For a specific transition, sets a cutoff for the sum of the most important features in descending order.</p> <code>0.8</code> <p>Returns:</p> Type Description <code>dict</code> <p>Dictionary with keys representing detected transitions. E.g., key '3_8' means transition between index 3 and index 8 according to the prob array. Values are lists representing mean and standard deviations of the feature importance using the length of the list equaling the number of features in the provided dataset for that transition.</p> Source code in <code>MDTerp/utils.py</code> <pre><code>def transition_summary(all_result_loc: str, importance_coverage: float = 0.8) -&gt; dict:\n    \"\"\"\n    Function summarizing MDTerp results for all the transitions present in the dataset.\n\n    Args:\n        all_results_loc (str): Location to save MDTerp results.\n        importance_coverage (float): For a specific transition, sets a cutoff for the sum of the most important features in descending order.\n\n    Returns:\n        dict: Dictionary with keys representing detected transitions. E.g., key '3_8' means transition between index 3 and index 8 according to the prob array. Values are lists representing mean and standard deviations of the feature importance using the length of the list equaling the number of features in the provided dataset for that transition.\n    \"\"\"\n    with open(all_result_loc, 'rb') as f:\n        loaded_dict = pickle.load(f)  \n    # Save all the unique transitions\n    transitions = []\n    for ii in loaded_dict:\n        transitions.append(loaded_dict[ii][0])\n    # Save summary results for each transition\n    summary_imp = {}\n    for ii in np.unique(transitions):\n        summary_imp[ii] = []\n    for ii in loaded_dict:\n        summary_imp[loaded_dict[ii][0]].append(loaded_dict[ii][1])\n    for ii in summary_imp:\n        tmp_a = np.mean(summary_imp[ii], axis = 0)\n        # Normalize results for the transition\n        normalization = np.sum(tmp_a)\n        tmp_a = tmp_a/normalization\n        tmp_b = np.std(summary_imp[ii], axis = 0)/normalization\n\n        trim_args = np.argsort(tmp_a)[::-1]\n        trim_vals = np.sort(tmp_a)[::-1]\n        # Discard irrelevant features for each transition, based on the importance_coverage hyperparameter\n        cutoff_k = 0\n        current_coverage = 0\n        while current_coverage &lt; importance_coverage:\n          try:  \n            current_coverage += trim_vals[cutoff_k]\n            cutoff_k += 1\n          except:\n            break\n\n        tmp_a[trim_args[cutoff_k:]] = 0\n        tmp_b[trim_args[cutoff_k:]] = 0\n\n        summary_imp[ii] = [tmp_a, tmp_b]\n\n    return summary_imp\n</code></pre>"}]}