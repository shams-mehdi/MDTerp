{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Welcome to MDTerp","text":"<p>A python project for interpreting molecular dynamics (MD) trajectory metastable state classifications from machine-learning models</p> <ul> <li>Free software: MIT License</li> <li>Documentation: https://shams-mehdi.github.io/MDTerp</li> </ul>"},{"location":"#features","title":"Features","text":"<ul> <li>Scans your blackbox model trained on MD data for feature importance.</li> </ul>"},{"location":"MDTerp/","title":"MDTerp module","text":"<p>MDTerp.base.run - Main class for implementing MDTERP.</p> Source code in <code>MDTerp/base.py</code> <pre><code>class run:\n    \"\"\"\n    MDTerp.base.run - Main class for implementing MDTERP.\n    \"\"\"\n    def __init__(self, np_data: np.ndarray, model_function_loc: str, numeric_dict: dict = {}, angle_dict: dict = {}, sin_cos_dict:dict = {}, save_dir: str = './results/', prob_threshold: float = 0.48, point_max: int = 20, num_samples: int = 5000, cutoff: int = 25, seed: int = 0, unfaithfulness_threshold: float = 0.01) -&gt; None:\n        \"\"\"\n        Constructor for the MDTerp.base.run class.\n\n        Args:\n            np_data (np.ndarray): Black-box training data.\n            model_function_loc (str): Location of a human-readable file containing two functions called 'load_model', and 'run_model'. 'load_model' must not take any arguments and should return the black-box model. 'run_model' must be a function that takes two arguments: the model and data respectively, and returns metastable state probabilities. Go to https://shams-mehdi.github.io/MDTerp/blackbox/ for example blackbox models.\n            numeric_dict (dict): Python dictionary, each key represents the name of a numeric feature (non-periodic). Values should be lists with a single element with the index of the corresponding numpy array in np_data.\n            angle_dict (dict): Python dictionary, each key represents the name of an angular feature in [-pi, pi]. Values should be lists with a single element with the index of the corresponding numpy array in np_data.\n            sin_cos_dict (dict): Python dictionary, each key represents the name of an angular feature. Values should be lists with two elements with the sine, cosine indices respectively of the corresponding numpy array in np_data.\n            save_dir (str): Location to save MDTerp results.\n            prob_threshold (float): Threshold for identifying if a sample belongs to transition state predicted by the black-box model. If metastable state probability &gt; threshold for two different classes for a specific sample, it's suitable for analysis (Default: 0.48).\n            point_max (int): If too many suitable points exist for a specific transition (e.g., transition between metastable state 3 and 8), point_max sets maximum number of points chosen for analysis. Points chosen from a uniform distribution (Default: 20).\n            num_samples (int): Size of the perturbed neighborhood (Default: 5000). Ad hoc rule: should be proportional to the square root of the number of features.\n            cutoff (int): Maximum number of features selected for final round of MDTerp and forward feature selection.\n            seed (int): Random seed.\n        unf_threshold (float): Hyperparameter that sets a lower limit on unfaithafulness. Forward feature selection ends when unfaithfulness reaches lower than this threshold.\n\n        Returns:\n            None\n        \"\"\"\n        # Initializing necessities\n        os.makedirs(save_dir, exist_ok = True)\n        tmp_dir = save_dir + 'tmp/'\n        os.makedirs(tmp_dir, exist_ok = True)\n        logger = log_maker(save_dir)\n        input_summary(logger, numeric_dict, angle_dict, sin_cos_dict, save_dir, np_data)\n\n        # Load Model\n        logger.info('Loading blackbox model &gt;&gt;&gt; ')\n        with open(model_function_loc, 'r') as file:\n            func_code = file.read()\n        local_ns = {}\n        exec(func_code, globals(), local_ns)\n        model_loc, model = local_ns[\"load_model\"]()\n        logger.info(\"Model loaded from location &gt;&gt;&gt; \" + model_loc)\n\n        # Identify transition states for given/training dataset\n        state_probabilities = local_ns[\"run_model\"](model, np_data)\n        points = picker_fn(state_probabilities, prob_threshold, point_max)\n        logger.info(\"Number of state transitions detected &gt;&gt;&gt; \" + str(len(list(points.keys()))))\n        logger.info(\"Probability threshold, maximum number of points per transition &gt;&gt;&gt; \" + str(prob_threshold) + \", \" + str(point_max) )\n        logger.info(100*'-')\n\n        # Loop over all the transitions\n        importance_master = {}\n        for transition in points:\n            logger.info(\"Starting transition &gt;&gt;&gt; \" + transition)\n            for point in range(len(points[transition])):\n                index = points[transition][point]\n                given_indices, indices_names = generate_neighborhood(tmp_dir, numeric_dict, angle_dict, sin_cos_dict, np_data, index, seed, num_samples, selected_features = False)\n                state_probabilities2 = local_ns[\"run_model\"](model, np.load(tmp_dir + 'DATA/make_prediction.npy'))\n                TERP_dat = np.load(tmp_dir + 'DATA/TERP_dat.npy')\n                selected_features = init_model(TERP_dat, state_probabilities2, cutoff, given_indices, seed)\n\n                generate_neighborhood(tmp_dir, numeric_dict, angle_dict, sin_cos_dict, np_data, index, seed, num_samples, selected_features)\n                state_probabilities3 = local_ns[\"run_model\"](model, np.load(tmp_dir + 'DATA_2/make_prediction.npy'))\n                TERP_dat = np.load(tmp_dir + 'DATA_2/TERP_dat.npy')\n                importance = final_model(TERP_dat, state_probabilities3, unfaithfulness_threshold, given_indices, selected_features, seed)\n\n                importance_master[index] = [transition, importance]\n                logger.info(\"Generated \" + str(point + 1) + \"/\" + str(len(points[transition])) + \" results!\")\n            logger.info(100*'_')\n\n        np.save(save_dir + 'MDTerp_feature_names.npy', indices_names)\n        with open(save_dir + 'MDTerp_results_all.pkl', 'wb') as f:\n            pickle.dump(importance_master, f)\n\n        logger.info(\"Feature names saved at &gt;&gt;&gt; \" + save_dir + 'MDTerp_feature_names.npy')\n        logger.info(\"All results saved at &gt;&gt;&gt; \" + save_dir + 'MDTerp_results_all.pkl')\n\n\n        shutil.rmtree(tmp_dir)\n        logger.info(\"Completed!!!\")\n\n        # Flush and close logger\n        for handler in logger.handlers[:]:\n            handler.close()\n            logger.removeHandler(handler)\n</code></pre>"},{"location":"MDTerp/#MDTerp.base.run.__init__","title":"<code>__init__(self, np_data, model_function_loc, numeric_dict={}, angle_dict={}, sin_cos_dict={}, save_dir='./results/', prob_threshold=0.48, point_max=20, num_samples=5000, cutoff=25, seed=0, unfaithfulness_threshold=0.01)</code>  <code>special</code>","text":"<p>Constructor for the MDTerp.base.run class.</p> <p>Parameters:</p> Name Type Description Default <code>np_data</code> <code>np.ndarray</code> <p>Black-box training data.</p> required <code>model_function_loc</code> <code>str</code> <p>Location of a human-readable file containing two functions called 'load_model', and 'run_model'. 'load_model' must not take any arguments and should return the black-box model. 'run_model' must be a function that takes two arguments: the model and data respectively, and returns metastable state probabilities. Go to https://shams-mehdi.github.io/MDTerp/blackbox/ for example blackbox models.</p> required <code>numeric_dict</code> <code>dict</code> <p>Python dictionary, each key represents the name of a numeric feature (non-periodic). Values should be lists with a single element with the index of the corresponding numpy array in np_data.</p> <code>{}</code> <code>angle_dict</code> <code>dict</code> <p>Python dictionary, each key represents the name of an angular feature in [-pi, pi]. Values should be lists with a single element with the index of the corresponding numpy array in np_data.</p> <code>{}</code> <code>sin_cos_dict</code> <code>dict</code> <p>Python dictionary, each key represents the name of an angular feature. Values should be lists with two elements with the sine, cosine indices respectively of the corresponding numpy array in np_data.</p> <code>{}</code> <code>save_dir</code> <code>str</code> <p>Location to save MDTerp results.</p> <code>'./results/'</code> <code>prob_threshold</code> <code>float</code> <p>Threshold for identifying if a sample belongs to transition state predicted by the black-box model. If metastable state probability &gt; threshold for two different classes for a specific sample, it's suitable for analysis (Default: 0.48).</p> <code>0.48</code> <code>point_max</code> <code>int</code> <p>If too many suitable points exist for a specific transition (e.g., transition between metastable state 3 and 8), point_max sets maximum number of points chosen for analysis. Points chosen from a uniform distribution (Default: 20).</p> <code>20</code> <code>num_samples</code> <code>int</code> <p>Size of the perturbed neighborhood (Default: 5000). Ad hoc rule: should be proportional to the square root of the number of features.</p> <code>5000</code> <code>cutoff</code> <code>int</code> <p>Maximum number of features selected for final round of MDTerp and forward feature selection.</p> <code>25</code> <code>seed</code> <code>int</code> <p>Random seed.</p> <code>0</code> <p>unf_threshold (float): Hyperparameter that sets a lower limit on unfaithafulness. Forward feature selection ends when unfaithfulness reaches lower than this threshold.</p> <p>Returns:</p> Type Description <code>None</code> <p>None</p> Source code in <code>MDTerp/base.py</code> <pre><code>def __init__(self, np_data: np.ndarray, model_function_loc: str, numeric_dict: dict = {}, angle_dict: dict = {}, sin_cos_dict:dict = {}, save_dir: str = './results/', prob_threshold: float = 0.48, point_max: int = 20, num_samples: int = 5000, cutoff: int = 25, seed: int = 0, unfaithfulness_threshold: float = 0.01) -&gt; None:\n    \"\"\"\n    Constructor for the MDTerp.base.run class.\n\n    Args:\n        np_data (np.ndarray): Black-box training data.\n        model_function_loc (str): Location of a human-readable file containing two functions called 'load_model', and 'run_model'. 'load_model' must not take any arguments and should return the black-box model. 'run_model' must be a function that takes two arguments: the model and data respectively, and returns metastable state probabilities. Go to https://shams-mehdi.github.io/MDTerp/blackbox/ for example blackbox models.\n        numeric_dict (dict): Python dictionary, each key represents the name of a numeric feature (non-periodic). Values should be lists with a single element with the index of the corresponding numpy array in np_data.\n        angle_dict (dict): Python dictionary, each key represents the name of an angular feature in [-pi, pi]. Values should be lists with a single element with the index of the corresponding numpy array in np_data.\n        sin_cos_dict (dict): Python dictionary, each key represents the name of an angular feature. Values should be lists with two elements with the sine, cosine indices respectively of the corresponding numpy array in np_data.\n        save_dir (str): Location to save MDTerp results.\n        prob_threshold (float): Threshold for identifying if a sample belongs to transition state predicted by the black-box model. If metastable state probability &gt; threshold for two different classes for a specific sample, it's suitable for analysis (Default: 0.48).\n        point_max (int): If too many suitable points exist for a specific transition (e.g., transition between metastable state 3 and 8), point_max sets maximum number of points chosen for analysis. Points chosen from a uniform distribution (Default: 20).\n        num_samples (int): Size of the perturbed neighborhood (Default: 5000). Ad hoc rule: should be proportional to the square root of the number of features.\n        cutoff (int): Maximum number of features selected for final round of MDTerp and forward feature selection.\n        seed (int): Random seed.\n    unf_threshold (float): Hyperparameter that sets a lower limit on unfaithafulness. Forward feature selection ends when unfaithfulness reaches lower than this threshold.\n\n    Returns:\n        None\n    \"\"\"\n    # Initializing necessities\n    os.makedirs(save_dir, exist_ok = True)\n    tmp_dir = save_dir + 'tmp/'\n    os.makedirs(tmp_dir, exist_ok = True)\n    logger = log_maker(save_dir)\n    input_summary(logger, numeric_dict, angle_dict, sin_cos_dict, save_dir, np_data)\n\n    # Load Model\n    logger.info('Loading blackbox model &gt;&gt;&gt; ')\n    with open(model_function_loc, 'r') as file:\n        func_code = file.read()\n    local_ns = {}\n    exec(func_code, globals(), local_ns)\n    model_loc, model = local_ns[\"load_model\"]()\n    logger.info(\"Model loaded from location &gt;&gt;&gt; \" + model_loc)\n\n    # Identify transition states for given/training dataset\n    state_probabilities = local_ns[\"run_model\"](model, np_data)\n    points = picker_fn(state_probabilities, prob_threshold, point_max)\n    logger.info(\"Number of state transitions detected &gt;&gt;&gt; \" + str(len(list(points.keys()))))\n    logger.info(\"Probability threshold, maximum number of points per transition &gt;&gt;&gt; \" + str(prob_threshold) + \", \" + str(point_max) )\n    logger.info(100*'-')\n\n    # Loop over all the transitions\n    importance_master = {}\n    for transition in points:\n        logger.info(\"Starting transition &gt;&gt;&gt; \" + transition)\n        for point in range(len(points[transition])):\n            index = points[transition][point]\n            given_indices, indices_names = generate_neighborhood(tmp_dir, numeric_dict, angle_dict, sin_cos_dict, np_data, index, seed, num_samples, selected_features = False)\n            state_probabilities2 = local_ns[\"run_model\"](model, np.load(tmp_dir + 'DATA/make_prediction.npy'))\n            TERP_dat = np.load(tmp_dir + 'DATA/TERP_dat.npy')\n            selected_features = init_model(TERP_dat, state_probabilities2, cutoff, given_indices, seed)\n\n            generate_neighborhood(tmp_dir, numeric_dict, angle_dict, sin_cos_dict, np_data, index, seed, num_samples, selected_features)\n            state_probabilities3 = local_ns[\"run_model\"](model, np.load(tmp_dir + 'DATA_2/make_prediction.npy'))\n            TERP_dat = np.load(tmp_dir + 'DATA_2/TERP_dat.npy')\n            importance = final_model(TERP_dat, state_probabilities3, unfaithfulness_threshold, given_indices, selected_features, seed)\n\n            importance_master[index] = [transition, importance]\n            logger.info(\"Generated \" + str(point + 1) + \"/\" + str(len(points[transition])) + \" results!\")\n        logger.info(100*'_')\n\n    np.save(save_dir + 'MDTerp_feature_names.npy', indices_names)\n    with open(save_dir + 'MDTerp_results_all.pkl', 'wb') as f:\n        pickle.dump(importance_master, f)\n\n    logger.info(\"Feature names saved at &gt;&gt;&gt; \" + save_dir + 'MDTerp_feature_names.npy')\n    logger.info(\"All results saved at &gt;&gt;&gt; \" + save_dir + 'MDTerp_results_all.pkl')\n\n\n    shutil.rmtree(tmp_dir)\n    logger.info(\"Completed!!!\")\n\n    # Flush and close logger\n    for handler in logger.handlers[:]:\n        handler.close()\n        logger.removeHandler(handler)\n</code></pre>"},{"location":"changelog/","title":"Changelog","text":""},{"location":"changelog/#v100-07312025","title":"v1.0.0 - 07/31/2025","text":"<p>Improvement:</p> <ul> <li>MDTerp published</li> </ul>"},{"location":"contributing/","title":"Contributing","text":"<p>Contributions are welcome, and they are greatly appreciated! Every little bit helps, and credit will always be given.</p> <p>You can contribute in many ways:</p>"},{"location":"contributing/#types-of-contributions","title":"Types of Contributions","text":""},{"location":"contributing/#report-bugs","title":"Report Bugs","text":"<p>Report bugs at https://github.com/shams-mehdi/MDTerp/issues.</p> <p>If you are reporting a bug, please include:</p> <ul> <li>Your operating system name and version.</li> <li>Any details about your local setup that might be helpful in troubleshooting.</li> <li>Detailed steps to reproduce the bug.</li> </ul>"},{"location":"contributing/#fix-bugs","title":"Fix Bugs","text":"<p>Look through the GitHub issues for bugs. Anything tagged with <code>bug</code> and <code>help wanted</code> is open to whoever wants to implement it.</p>"},{"location":"contributing/#implement-features","title":"Implement Features","text":"<p>Look through the GitHub issues for features. Anything tagged with <code>enhancement</code> and <code>help wanted</code> is open to whoever wants to implement it.</p>"},{"location":"contributing/#write-documentation","title":"Write Documentation","text":"<p>MDTerp could always use more documentation, whether as part of the official MDTerp docs, in docstrings, or even on the web in blog posts, articles, and such.</p>"},{"location":"contributing/#submit-feedback","title":"Submit Feedback","text":"<p>The best way to send feedback is to file an issue at https://github.com/shams-mehdi/MDTerp/issues.</p> <p>If you are proposing a feature:</p> <ul> <li>Explain in detail how it would work.</li> <li>Keep the scope as narrow as possible, to make it easier to implement.</li> <li>Remember that this is a volunteer-driven project, and that contributions are welcome :)</li> </ul>"},{"location":"contributing/#get-started","title":"Get Started!","text":"<p>Ready to contribute? Here's how to set up MDTerp for local development.</p> <ol> <li> <p>Fork the MDTerp repo on GitHub.</p> </li> <li> <p>Clone your fork locally:</p> <pre><code>$ git clone git@github.com:your_name_here/MDTerp.git\n</code></pre> </li> <li> <p>Install your local copy into a virtualenv. Assuming you have     virtualenvwrapper installed, this is how you set up your fork for     local development:</p> <pre><code>$ mkvirtualenv MDTerp\n$ cd MDTerp/\n$ python setup.py develop\n</code></pre> </li> <li> <p>Create a branch for local development:</p> <pre><code>$ git checkout -b name-of-your-bugfix-or-feature\n</code></pre> <p>Now you can make your changes locally.</p> </li> <li> <p>When you're done making changes, check that your changes pass flake8     and the tests, including testing other Python versions with tox:</p> <pre><code>$ flake8 MDTerp tests\n$ python setup.py test or pytest\n$ tox\n</code></pre> <p>To get flake8 and tox, just pip install them into your virtualenv.</p> </li> <li> <p>Commit your changes and push your branch to GitHub:</p> <pre><code>$ git add .\n$ git commit -m \"Your detailed description of your changes.\"\n$ git push origin name-of-your-bugfix-or-feature\n</code></pre> </li> <li> <p>Submit a pull request through the GitHub website.</p> </li> </ol>"},{"location":"contributing/#pull-request-guidelines","title":"Pull Request Guidelines","text":"<p>Before you submit a pull request, check that it meets these guidelines:</p> <ol> <li>The pull request should include tests.</li> <li>If the pull request adds functionality, the docs should be updated.     Put your new functionality into a function with a docstring, and add     the feature to the list in README.rst.</li> <li>The pull request should work for Python 3.8 and later, and     for PyPy. Check https://github.com/shams-mehdi/MDTerp/pull_requests and make sure that the tests pass for all     supported Python versions.</li> </ol>"},{"location":"faq/","title":"FAQ","text":""},{"location":"final_analysis/","title":"MDTerp module","text":"<p>MDTerp.final_analysis.py \u2013 Final MDTerp round for implementing forward feature selection and attributing feature importance.</p>"},{"location":"final_analysis/#MDTerp.final_analysis.SGDreg","title":"<code>SGDreg(data, labels, seed, alpha=1.0)</code>","text":"<p>Function for implementing linear regression using stochastic gradient descent.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>np.ndarray</code> <p>Numpy 2D array containing similarity weighted training data for the black-box model. Samples along rows and features along columns.</p> required <code>labels</code> <code>np.ndarray</code> <p>Numpy array containing metastable state prediction probabilities for a perturbed neighborhood corresponding to a specific sample. Includes the state for which the original sample has the highest probability.</p> required <code>seed</code> <code>int</code> <p>Random seed.</p> required <code>alpha</code> <code>float</code> <p>L2 norm of Ridge regression (Default: 1.0).</p> <code>1.0</code> <p>Returns:</p> Type Description <code>np.ndarray</code> <p>Numpy array with coefficients of all the features of the fitted linear model. float: Intercept of the fitted linear model.</p> Source code in <code>MDTerp/final_analysis.py</code> <pre><code>def SGDreg(data: np.ndarray, labels: np.ndarray, seed: int, alpha: float = 1.0) -&gt; Tuple[np.ndarray, float]:\n    \"\"\"\n    Function for implementing linear regression using stochastic gradient descent.\n\n    Args:\n        data (np.ndarray): Numpy 2D array containing similarity weighted training data for the black-box model. Samples along rows and features along columns.\n        labels (np.ndarray): Numpy array containing metastable state prediction probabilities for a perturbed neighborhood corresponding to a specific sample. Includes the state for which the original sample has the highest probability.\n        seed (int): Random seed.\n        alpha (float): L2 norm of Ridge regression (Default: 1.0).\n\n    Returns:\n        np.ndarray: Numpy array with coefficients of all the features of the fitted linear model.\n        float: Intercept of the fitted linear model.\n    \"\"\"\n    clf = Ridge(alpha, random_state = seed, solver = 'saga')\n    clf.fit(data,labels.ravel())\n    coefficients = clf.coef_\n    intercept = clf.intercept_\n    return coefficients, intercept\n</code></pre>"},{"location":"final_analysis/#MDTerp.final_analysis.charac_theta","title":"<code>charac_theta(d_U, d_S)</code>","text":"<p>Function for computing change in unfaithfulness per unit change in interpretation entropy as number of features used to build linear model increases by 1.</p> <p>Parameters:</p> Name Type Description Default <code>d_U</code> <code>np.ndarray</code> <p>Change in unfaithfulness with increasing features in linear models.</p> required <code>d_S</code> <code>np.ndarray</code> <p>Change in interpretation entropy with increasing features in linear models.</p> required <p>Returns:</p> Type Description <code>np.ndarray</code> <p>Change in unfaithfulness per unit change in interpretation entropy.</p> Source code in <code>MDTerp/final_analysis.py</code> <pre><code>def charac_theta(d_U: np.ndarray,d_S: np.ndarray) -&gt; np.ndarray:\n  \"\"\"\n    Function for computing change in unfaithfulness per unit change in interpretation entropy as number of features used to build linear model increases by 1.\n\n    Args:\n        d_U (np.ndarray): Change in unfaithfulness with increasing features in linear models.\n        d_S (np.ndarray): Change in interpretation entropy with increasing features in linear models.\n\n    Returns:\n        np.ndarray: Change in unfaithfulness per unit change in interpretation entropy.\n  \"\"\"\n  return -d_U/d_S\n</code></pre>"},{"location":"final_analysis/#MDTerp.final_analysis.final_model","title":"<code>final_model(neighborhood_data, pred_proba, unf_threshold, given_indices, selected_features, seed)</code>","text":"<p>Function for computing final feature importance by implementing forward feature selection.</p> <p>Parameters:</p> Name Type Description Default <code>neighborhood_data</code> <code>np.ndarray</code> <p>Perturbed data generated by MDTerp.neighborhood.py.</p> required <code>pred_proba</code> <code>np.ndarray</code> <p>Metastable state probabilities obtained from the black-box.</p> required <code>unf_threshold</code> <code>float</code> <p>Hyperparameter setting a lower limit on unfaithafulness. Forward feature selection ends when unfaithfulness reaches lower than this threshold.</p> required <code>given_indices</code> <code>np.ndarray</code> <p>Indices of the features to perform final round of MDTerp on.</p> required <code>seed</code> <code>int</code> <p>Random seed.</p> required <p>Returns:</p> Type Description <code>np.ndarray</code> <p>Normalized feature importance.</p> Source code in <code>MDTerp/final_analysis.py</code> <pre><code>def final_model(neighborhood_data: np.ndarray, pred_proba: np.ndarray, unf_threshold: float, given_indices: np.ndarray, selected_features: np.ndarray, seed:int) -&gt; np.ndarray:\n    \"\"\"\n    Function for computing final feature importance by implementing forward feature selection.\n\n    Args:\n        neighborhood_data (np.ndarray): Perturbed data generated by MDTerp.neighborhood.py.\n        pred_proba (np.ndarray): Metastable state probabilities obtained from the black-box.\n        unf_threshold (float): Hyperparameter setting a lower limit on unfaithafulness. Forward feature selection ends when unfaithfulness reaches lower than this threshold.\n        given_indices (np.ndarray): Indices of the features to perform final round of MDTerp on.\n        seed (int): Random seed.\n\n    Returns:\n        np.ndarray: Normalized feature importance.\n    \"\"\"\n    tot_feat = given_indices[0].shape[0] + given_indices[1].shape[0] + given_indices[2].shape[0]\n\n    all_features = []\n    for i in range(len(selected_features[0])):\n        all_features.append(selected_features[0][i])\n    for i in range(len(selected_features[1])):\n        all_features.append(selected_features[1][i])  \n    for i in range(len(selected_features[2])):\n        all_features.append(given_indices[0].shape[0] + given_indices[1].shape[0] + np.where(selected_features[2][i][0] == given_indices[2])[0][0])  \n\n    k_max = neighborhood_data.shape[1]\n\n    explain_class = np.argmax(pred_proba[0,:])\n\n    target = pred_proba[:,explain_class]\n\n    threshold, upper, lower = 0.5, 1, 0\n    target_binarized = np.where(target&gt;threshold, upper, lower)\n\n    clf = lda()\n    clf.fit(neighborhood_data,target_binarized)\n    projected_data = clf.transform(neighborhood_data)\n    weights = similarity_kernel(projected_data.reshape(-1,1), 1)\n\n    predict_proba = pred_proba[:,explain_class]\n    data = neighborhood_data*(weights**0.5).reshape(-1,1)\n    labels = target.reshape(-1,1)*(weights.reshape(-1,1)**0.5)\n\n    best_parameters_master = []\n    best_parameters_converted = []\n    best_unfaithfulness_master = []\n    best_interp_master = []\n\n    N = data.shape[1]\n    k_array = np.arange(1,k_max+1)\n\n    for k in k_array:\n      unfaithfulness_calc(k, N, data, predict_proba, best_parameters_master, labels, best_interp_master, best_parameters_converted, best_unfaithfulness_master, tot_feat, all_features, seed)\n\n\n    optimal_k = 1\n\n\n    if N&lt;=3:\n      for i in range(1,N):\n        prime_model = -1\n        if best_unfaithfulness_master[i]&lt;=best_unfaithfulness_master[i-1] - unf_threshold:\n          prime_model = copy.deepcopy(i)-1\n          continue\n        else:\n          break\n\n    else:\n      charac_theta_mast = []\n\n      d_U_lst = []\n      d_S_lst = []\n      for i in range(1, len(all_features)):\n        d_U_lst.append(best_unfaithfulness_master[i] - best_unfaithfulness_master[i-1])\n        d_S_lst.append(best_interp_master[i] - best_interp_master[i-1])\n\n      for i in range(len(all_features)-1):\n        charac_theta_mast.append(charac_theta(d_U_lst[i], d_S_lst[i]))\n\n      range_theta_mast = []\n      for i in range(1,len(charac_theta_mast)):\n        range_theta_mast.append(np.array(charac_theta_mast)[i]-np.array(charac_theta_mast)[i-1])\n\n      prime_model = np.argmin(np.array(range_theta_mast))\n\n    return np.absolute(np.array(best_parameters_converted)[prime_model+1])/np.sum(np.absolute(np.array(best_parameters_converted)[prime_model+1]))\n</code></pre>"},{"location":"final_analysis/#MDTerp.final_analysis.interp","title":"<code>interp(coef_array)</code>","text":"<p>Function for computing interpretation entropy of the coefficients of a fitted linear model.</p> <p>Parameters:</p> Name Type Description Default <code>coef_array</code> <code>np.ndarray</code> <p>Numpy array with coefficients of all the features of the fitted linear model.</p> required <p>Returns:</p> Type Description <code>float</code> <p>Interpretation entropy of the coefficients of a fitted linear model.</p> Source code in <code>MDTerp/final_analysis.py</code> <pre><code>def interp(coef_array: np.ndarray) -&gt; float:\n  \"\"\"\n    Function for computing interpretation entropy of the coefficients of a fitted linear model.\n\n    Args:\n        coef_array (np.ndarray): Numpy array with coefficients of all the features of the fitted linear model.\n\n    Returns:\n        float: Interpretation entropy of the coefficients of a fitted linear model.\n  \"\"\"\n  a = np.absolute(coef_array)/np.sum(np.absolute(coef_array))\n  t = 0\n  for i in range(a.shape[0]):\n    if a[i]==0:\n      continue\n    else:\n      t += a[i]*np.log(a[i])\n  return -t/np.log(coef_array.shape[0])\n</code></pre>"},{"location":"final_analysis/#MDTerp.final_analysis.similarity_kernel","title":"<code>similarity_kernel(data, kernel_width=1.0)</code>","text":"<p>Function for computing similarity\u2208[0,1] of a perturbed sample with respect to the original sample using LDA transformed distance.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>np.ndarray</code> <p>LDA transformed data.</p> required <code>kernel_width</code> <code>float</code> <p>Width of the similarity kernel (Default: 1.0).</p> <code>1.0</code> <p>Returns:</p> Type Description <code>np.ndarray</code> <p>Similarity\u2208[0,1] of neighborhood.</p> Source code in <code>MDTerp/final_analysis.py</code> <pre><code>def similarity_kernel(data: np.ndarray, kernel_width: float = 1.0) -&gt; np.ndarray:\n    \"\"\"\n    Function for computing similarity\u2208[0,1] of a perturbed sample with respect to the original sample using LDA transformed distance.\n\n    Args:\n        data (np.ndarray): LDA transformed data.\n        kernel_width (float): Width of the similarity kernel (Default: 1.0).\n\n    Returns:\n        np.ndarray: Similarity\u2208[0,1] of neighborhood.\n    \"\"\"\n    distances = met.pairwise_distances(data,data[0].reshape(1, -1),metric='euclidean').ravel()\n    return np.sqrt(np.exp(-(distances ** 2) / kernel_width ** 2))\n</code></pre>"},{"location":"final_analysis/#MDTerp.final_analysis.unfaithfulness_calc","title":"<code>unfaithfulness_calc(k, N, data, predict_proba, best_parameters_master, labels, best_interp_master, best_parameters_converted, best_unfaithfulness_master, tot_feat, all_features, seed)</code>","text":"<p>Function for implementing linear regression using stochastic gradient descent.</p> <p>Parameters:</p> Name Type Description Default <code>k</code> <code>int</code> <p>Number of features for building local linear model.</p> required <code>N</code> <code>int</code> <p>Number of features selected for detailed analysis.</p> required <code>data</code> <code>np.ndarray</code> <p>Numpy 2D array containing similarity weighted training data for the black-box model. Samples along rows and features along columns.</p> required <code>predict_proba</code> <code>np.ndarray</code> <p>Numpy array containing metastable state prediction probabilities for a perturbed neighborhood corresponding to a specific sample. Includes the state for which the original sample has the highest probability.</p> required <code>best_parameters_master</code> <code>list</code> <p>List of lists that saves the best fit coefficients for linear models built using k=1, .., N features.</p> required <code>best_interp_master</code> <code>list</code> <p>List that saves the interpretation entropy for the linear models built using k=1,...,N features.</p> required <code>best_parameters_converted</code> <code>list</code> <p>List of lists that saves the best fit coefficients for linear models built using k=1, .., N features, and imputes the discarded features in initial MDTerp round with 0 importance to preserve feature ID.</p> required <code>best_unfaithfulness_master</code> <code>list</code> <p>List that saves the unfaithfulness of the best fit linear models built using k=1, ..., N features.</p> required <code>tot_feat</code> <code>int</code> <p>Total number of features in the dataset including both discarded features and features under analysis.</p> required <code>all_features</code> <code>np.ndarray</code> <p>Indices of the features selected for detailed MDTerp analysis.</p> required <code>seed</code> <code>int</code> <p>Random seed.</p> required <p>Returns:</p> Type Description <code>None</code> <p>None</p> Source code in <code>MDTerp/final_analysis.py</code> <pre><code>def unfaithfulness_calc(k: int, N: int, data: np.ndarray, predict_proba: np.ndarray, best_parameters_master: list, labels: np.ndarray, best_interp_master: list, best_parameters_converted: list, best_unfaithfulness_master: list, tot_feat: int, all_features: np.ndarray, seed: int) -&gt; None:\n  \"\"\"\n    Function for implementing linear regression using stochastic gradient descent.\n\n    Args:\n        k (int): Number of features for building local linear model.\n        N (int): Number of features selected for detailed analysis.\n        data (np.ndarray): Numpy 2D array containing similarity weighted training data for the black-box model. Samples along rows and features along columns.\n        predict_proba (np.ndarray): Numpy array containing metastable state prediction probabilities for a perturbed neighborhood corresponding to a specific sample. Includes the state for which the original sample has the highest probability.\n        best_parameters_master (list): List of lists that saves the best fit coefficients for linear models built using k=1, .., N features.\n        best_interp_master (list): List that saves the interpretation entropy for the linear models built using k=1,...,N features.\n        best_parameters_converted (list): List of lists that saves the best fit coefficients for linear models built using k=1, .., N features, and imputes the discarded features in initial MDTerp round with 0 importance to preserve feature ID.\n        best_unfaithfulness_master (list): List that saves the unfaithfulness of the best fit linear models built using k=1, ..., N features.\n        tot_feat (int): Total number of features in the dataset including both discarded features and features under analysis.\n        all_features (np.ndarray): Indices of the features selected for detailed MDTerp analysis.\n        seed (int): Random seed.\n\n    Returns:\n        None\n  \"\"\" \n  models = []\n  TERP_SGD_parameters = []\n  TERP_SGD_unfaithfulness = []\n  TERP_SGD_interp = []\n  if k == 1:\n    inherited_nonzero = np.array([],dtype=int)\n    inherited_zero = np.arange(N)\n\n  elif k &gt; 1:\n    inherited_nonzero = np.nonzero(best_parameters_master[k-2][:-1])[0]\n    inherited_zero = np.where(best_parameters_master[k-2][:-1] == 0)[0]\n\n  for i in range(N-k+1):\n    models.append(np.append(inherited_nonzero, inherited_zero[i]))\n    result_a, result_b = SGDreg(data[:,models[i]], labels, seed)\n    parameters = np.zeros((N+1))\n    parameters[models[i]] = result_a\n    parameters[-1] = result_b\n    TERP_SGD_parameters.append(parameters)\n    residual = np.corrcoef(labels[:,0],(np.column_stack((data, np.ones((data.shape[0]))))@parameters[:]).reshape(-1,1)[:,0])[0,1]\n    TERP_SGD_unfaithfulness.append(1-np.absolute(residual))\n    TERP_SGD_interp.append(interp(TERP_SGD_parameters[-1][:-1]))\n    TERP_SGD_IFE = np.array(TERP_SGD_unfaithfulness)\n\n  best_model = np.argsort(TERP_SGD_IFE)[0]\n  best_parameters_master.append(TERP_SGD_parameters[best_model])\n  best_interp_master.append(TERP_SGD_interp[best_model])\n\n  temp_coef_1 = TERP_SGD_parameters[best_model][:-1]\n  temp_coef_2 = np.zeros((tot_feat))\n  temp_coef_2[all_features] = copy.deepcopy(temp_coef_1)\n  best_parameters_converted.append(temp_coef_2)\n  best_unfaithfulness_master.append(TERP_SGD_unfaithfulness[best_model])\n\n  surrogate_pred = data@TERP_SGD_parameters[best_model][:-1]\n</code></pre>"},{"location":"final_analysis/#MDTerp.final_analysis.zeta","title":"<code>zeta(U, S, theta)</code>","text":"<p>Function for computing interpretation free energy.</p> <p>Parameters:</p> Name Type Description Default <code>U</code> <code>np.ndarray</code> <p>Numpy array with unfaithfulness of the best models for number of features, k = 1, ..., N.</p> required <code>S</code> <code>np.ndarray</code> <p>Numpy array with interpretation entropy of the best models for number of features, k = 1, ..., N.</p> required <code>theta</code> <code>float</code> <p>Temperature of the fitted linear model.</p> required <p>Returns:</p> Type Description <code>np.ndarray</code> <p>Interpretation free energy.</p> Source code in <code>MDTerp/final_analysis.py</code> <pre><code>def zeta(U: np.ndarray,S: np.ndarray,theta: float) -&gt; np.ndarray:\n  \"\"\"\n    Function for computing interpretation free energy.\n\n    Args:\n        U (np.ndarray): Numpy array with unfaithfulness of the best models for number of features, k = 1, ..., N.\n        S (np.ndarray): Numpy array with interpretation entropy of the best models for number of features, k = 1, ..., N.\n        theta (float): Temperature of the fitted linear model.\n\n    Returns:\n        np.ndarray: Interpretation free energy.\n  \"\"\"\n  return U + theta*S\n</code></pre>"},{"location":"init_analysis/","title":"MDTerp module","text":"<p>MDTerp.init_analysis.py \u2013 Initial MDTerp round for discarding irrelevant features from analysis for the forward feature selection in MDTerp.final_analysis.py.</p>"},{"location":"init_analysis/#MDTerp.init_analysis.SGDreg","title":"<code>SGDreg(data, labels, seed, alpha=1.0)</code>","text":"<p>Function for implementing linear regression using stochastic gradient descent.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>np.ndarray</code> <p>Numpy 2D array containing similarity weighted training data for the black-box model. Samples along rows and features along columns.</p> required <code>labels</code> <code>np.ndarray</code> <p>Numpy array containing metastable state prediction probabilities for a perturbed neighborhood corresponding to a specific sample. Includes the state for which the original sample has the highest probability.</p> required <code>seed</code> <code>int</code> <p>Random seed.</p> required <code>alpha</code> <code>float</code> <p>L2 norm of Ridge regression (Default: 1.0).</p> <code>1.0</code> <p>Returns:</p> Type Description <code>np.ndarray</code> <p>Numpy array with coefficients of all the features of the fitted linear model. float: Intercept of the fitted linear model.</p> Source code in <code>MDTerp/init_analysis.py</code> <pre><code>def SGDreg(data: np.ndarray, labels: np.ndarray, seed: int, alpha: float = 1.0) -&gt; Tuple[np.ndarray, float]:\n    \"\"\"\n    Function for implementing linear regression using stochastic gradient descent.\n\n    Args:\n        data (np.ndarray): Numpy 2D array containing similarity weighted training data for the black-box model. Samples along rows and features along columns.\n        labels (np.ndarray): Numpy array containing metastable state prediction probabilities for a perturbed neighborhood corresponding to a specific sample. Includes the state for which the original sample has the highest probability.\n        seed (int): Random seed.\n        alpha (float): L2 norm of Ridge regression (Default: 1.0).\n\n    Returns:\n        np.ndarray: Numpy array with coefficients of all the features of the fitted linear model.\n        float: Intercept of the fitted linear model.\n    \"\"\"\n    clf = Ridge(alpha, random_state = seed, solver = 'saga')\n    clf.fit(data,labels.ravel())\n    coefficients = clf.coef_\n    intercept = clf.intercept_\n    return coefficients, intercept\n</code></pre>"},{"location":"init_analysis/#MDTerp.init_analysis.init_model","title":"<code>init_model(neighborhood_data, pred_proba, cutoff, given_indices, seed)</code>","text":"<p>Function fitting initial linear model for discarding irrelevant features and choosing promising features for detailed analysis.</p> <p>Parameters:</p> Name Type Description Default <code>neighborhood_data</code> <code>np.ndarray</code> <p>Perturbed data generated by MDTerp.neighborhood.py.</p> required <code>pred_proba</code> <code>np.ndarray</code> <p>Metastable state probabilities obtained from the black-box.</p> required <code>cutoff</code> <code>float</code> <p>Hyperparameter controlling how many features are discarded.</p> required <code>given_indices</code> <code>np.ndarray</code> <p>Indices of the features to perform first round of MDTerp on.</p> required <code>seed</code> <code>int</code> <p>Random seed.</p> required <p>Returns:</p> Type Description <code>np.ndarray</code> <p>List of three lists containing indices of the selected numeric, angular, sine/cosine features respectively for further analysis/forward feature selection.</p> Source code in <code>MDTerp/init_analysis.py</code> <pre><code>def init_model(neighborhood_data: np.ndarray, pred_proba: np.ndarray, cutoff: float, given_indices: np.ndarray, seed: int) -&gt; list:\n    \"\"\"\n    Function fitting initial linear model for discarding irrelevant features and choosing promising features for detailed analysis.\n\n    Args:\n        neighborhood_data (np.ndarray): Perturbed data generated by MDTerp.neighborhood.py.\n        pred_proba (np.ndarray): Metastable state probabilities obtained from the black-box.\n        cutoff (float): Hyperparameter controlling how many features are discarded.\n        given_indices (np.ndarray): Indices of the features to perform first round of MDTerp on.\n        seed (int): Random seed.\n\n    Returns:\n        np.ndarray: List of three lists containing indices of the selected numeric, angular, sine/cosine features respectively for further analysis/forward feature selection.\n    \"\"\"\n    explain_class = np.argmax(pred_proba[0,:])\n\n    target = pred_proba[:,explain_class]\n\n    threshold, upper, lower = 0.5, 1, 0\n    target_binarized = np.where(target&gt;threshold, upper, lower)\n\n    clf = lda()\n    clf.fit(neighborhood_data,target_binarized)\n    projected_data = clf.transform(neighborhood_data)\n    weights = similarity_kernel(projected_data.reshape(-1,1), 1)\n\n\n    predict_proba = pred_proba[:,explain_class]\n    data = neighborhood_data*(weights**0.5).reshape(-1,1)\n    labels = target.reshape(-1,1)*(weights.reshape(-1,1)**0.5)\n\n    coefficients_selection, intercept_selection = SGDreg(data, labels, seed)\n    coefficients_selection = coefficients_selection/np.sum(np.absolute(coefficients_selection))\n    selected_features = selection(coefficients_selection, cutoff)\n\n    selected_features_lst = [[], [], []]\n\n    for i in range(len(selected_features)):\n        if selected_features[i]&lt;given_indices[0].shape[0]:\n            selected_features_lst[0].append(given_indices[0][selected_features[i]])\n        else:\n            if selected_features[i]&lt;given_indices[0].shape[0] + given_indices[1].shape[0]:\n                selected_features_lst[1].append(given_indices[1][selected_features[i] - given_indices[0].shape[0]])\n            else:\n                selected_features_lst[2].append(given_indices[2][selected_features[i] - given_indices[0].shape[0] - given_indices[1].shape[0], :])\n\n    return selected_features_lst\n</code></pre>"},{"location":"init_analysis/#MDTerp.init_analysis.selection","title":"<code>selection(coefficients, threshold)</code>","text":"<p>Function for discarding irrelevant features with small absolute values of the coefficients from the fitted linear model.</p> <p>Parameters:</p> Name Type Description Default <code>coefficients</code> <code>np.ndarray</code> <p>Numpy array with coefficients of all the features of the fitted linear model.</p> required <code>threshold</code> <code>float</code> <p>Hyperparameter controlling how many features are discarded.</p> required <p>Returns:</p> Type Description <code>np.ndarray</code> <p>Numpy array containing indices of the selected features for further analysis/forward feature selection.</p> Source code in <code>MDTerp/init_analysis.py</code> <pre><code>def selection(coefficients: np.ndarray, threshold: float) -&gt; np.ndarray:\n    \"\"\"\n    Function for discarding irrelevant features with small absolute values of the coefficients from the fitted linear model.\n\n    Args:\n        coefficients (np.ndarray): Numpy array with coefficients of all the features of the fitted linear model.\n        threshold (float): Hyperparameter controlling how many features are discarded.\n\n    Returns:\n        np.ndarray: Numpy array containing indices of the selected features for further analysis/forward feature selection.\n    \"\"\"\n    coefficients_abs = np.absolute(coefficients)\n    selected_features = []\n    coverage = 0\n    for i in range(coefficients_abs.shape[0]):\n        if i==threshold:\n            break\n        coverage = coverage+np.sort(coefficients_abs)[::-1][i]/np.sum(coefficients_abs)\n        selected_features.append(np.argsort(coefficients_abs)[::-1][i])\n    return selected_features    \n</code></pre>"},{"location":"init_analysis/#MDTerp.init_analysis.similarity_kernel","title":"<code>similarity_kernel(data, kernel_width=1.0)</code>","text":"<p>Function for computing similarity\u2208[0,1] of a perturbed sample with respect to the original sample using LDA transformed distance.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>np.ndarray</code> <p>LDA transformed data.</p> required <code>kernel_width</code> <code>float</code> <p>Width of the similarity kernel (Default: 1.0).</p> <code>1.0</code> <p>Returns:</p> Type Description <code>np.ndarray</code> <p>Similarity\u2208[0,1] of neighborhood.</p> Source code in <code>MDTerp/init_analysis.py</code> <pre><code>def similarity_kernel(data: np.ndarray, kernel_width: float = 1.0) -&gt; np.ndarray:\n    \"\"\"\n    Function for computing similarity\u2208[0,1] of a perturbed sample with respect to the original sample using LDA transformed distance.\n\n    Args:\n        data (np.ndarray): LDA transformed data.\n        kernel_width (float): Width of the similarity kernel (Default: 1.0).\n\n    Returns:\n        np.ndarray: Similarity\u2208[0,1] of neighborhood.\n    \"\"\"\n    distances = met.pairwise_distances(data,data[0].reshape(1, -1),metric='euclidean').ravel()\n    return np.sqrt(np.exp(-(distances ** 2) / kernel_width ** 2))\n</code></pre>"},{"location":"installation/","title":"Installation","text":""},{"location":"installation/#stable-release","title":"Stable release","text":"<p>To install MDTerp, run this command in your terminal:</p> <pre><code>pip install MDTerp\n</code></pre> <p>This is the preferred method to install MDTerp, as it will always install the most recent stable release.</p> <p>If you don't have pip installed, this Python installation guide can guide you through the process.</p>"},{"location":"installation/#from-sources","title":"From sources","text":"<p>To install MDTerp from sources, run this command in your terminal:</p> <pre><code>pip install git+https://github.com/shams-mehdi/MDTerp\n</code></pre>"},{"location":"neighborhood/","title":"MDTerp module","text":"<p>MDTerp.neighborhood.py \u2013 Function for generating perturbed neighborhood samples.</p>"},{"location":"neighborhood/#MDTerp.neighborhood.generate_neighborhood","title":"<code>generate_neighborhood(save_dir, numeric_dict, angle_dict, sin_cos_dict, np_dat, index, seed, num_samples, selected_features=False)</code>","text":"<p>Function for creating a logger detailing MDTerp operations.</p> <p>Parameters:</p> Name Type Description Default <code>save_dir</code> <code>str</code> <p>Location to save MDTerp results.</p> required <code>numeric_dict</code> <code>dict</code> <p>Python dictionary, each key represents the name of a numeric feature (non-periodic). Values should be lists with a single element with the index of the corresponding numpy array in np_data.</p> required <code>angle_dict</code> <code>dict</code> <p>Python dictionary, each key represents the name of an angular feature in [-pi, pi]. Values should be lists with a single element with the index of the corresponding numpy array in np_data.</p> required <code>sin_cos_dict</code> <code>dict</code> <p>Python dictionary, each key represents the name of an angular feature. Values should be lists with two elements with the sine, cosine indices respectively of the corresponding numpy array in np_data.</p> required <code>np_dat</code> <code>np.ndarray</code> <p>Numpy 2D array containing training data for the black-box model. Samples along rows and features along columns.</p> required <code>index</code> <code>int</code> <p>Row/sample of the provided dataset using np_dat to analyze.</p> required <code>seed</code> <code>int</code> <p>Random seed.</p> required <code>num_samples</code> <code>int</code> <p>Size of the generated perturbed neighborhood.</p> required <code>selected_features</code> <code>Union[bool, List[int]]</code> <p>If False (Default), perturbs all the features/columns. Otherwise, List of integers represent subset of features to perturb.</p> <code>False</code> <p>Returns:</p> Type Description <code>list</code> <p>List of np.ndarray indicating indices of numeric, angular, sin_cos features respectively. list: List of the combined name of the features.</p> Source code in <code>MDTerp/neighborhood.py</code> <pre><code>def generate_neighborhood(save_dir: str, numeric_dict: dict, angle_dict: dict, sin_cos_dict: dict, np_dat: np.ndarray, index: int, seed: int, num_samples: int, selected_features: Union[bool, List[int]] = False):\n    \"\"\"\n    Function for creating a logger detailing MDTerp operations.\n\n    Args:\n        save_dir (str): Location to save MDTerp results.\n        numeric_dict (dict): Python dictionary, each key represents the name of a numeric feature (non-periodic). Values should be lists with a single element with the index of the corresponding numpy array in np_data.\n        angle_dict (dict): Python dictionary, each key represents the name of an angular feature in [-pi, pi]. Values should be lists with a single element with the index of the corresponding numpy array in np_data.\n        sin_cos_dict (dict): Python dictionary, each key represents the name of an angular feature. Values should be lists with two elements with the sine, cosine indices respectively of the corresponding numpy array in np_data.\n        np_dat (np.ndarray): Numpy 2D array containing training data for the black-box model. Samples along rows and features along columns.\n        index (int): Row/sample of the provided dataset using np_dat to analyze.\n        seed (int): Random seed.\n        num_samples (int): Size of the generated perturbed neighborhood.\n        selected_features: If False (Default), perturbs all the features/columns. Otherwise, List of integers represent subset of features to perturb.\n\n    Returns:\n        list: List of np.ndarray indicating indices of numeric, angular, sin_cos features respectively.\n        list: List of the combined name of the features.\n    \"\"\"\n    np.random.seed(seed)\n    if selected_features == False:\n        save_directory = save_dir + 'DATA'\n        os.makedirs(save_directory, exist_ok = True)\n\n        numeric_indices = []\n        angle_indices = []\n        sin_cos_indices = []\n\n        indices_names = []\n\n        for i in numeric_dict:\n                numeric_indices.append(numeric_dict[i])\n                indices_names.append(i)\n                assert numeric_dict[i][0] in np.arange(np_dat.shape[1]), 'Invalid numeric index'\n        for i in angle_dict:\n                angle_indices.append(angle_dict[i])\n                indices_names.append(i)\n                assert angle_dict[i][0] in np.arange(np_dat.shape[1]), 'Invalid angle index'\n        for i in sin_cos_dict:\n                sin_cos_indices.append(sin_cos_dict[i])\n                indices_names.append(i)\n                assert sin_cos_dict[i][0] in np.arange(np_dat.shape[1]), 'Invalid sin index'\n                assert sin_cos_dict[i][1] in np.arange(np_dat.shape[1]), 'Invalid cos index'\n\n        numeric_indices = np.array(numeric_indices).flatten()\n        angle_indices = np.array(angle_indices).flatten()\n        sin_cos_indices = np.array(sin_cos_indices)\n\n    else:\n      save_directory = save_dir + 'DATA_2'\n      os.makedirs(save_directory, exist_ok = True)\n\n      numeric_indices = np.array(selected_features[0])\n      angle_indices = np.array(selected_features[1])\n      sin_cos_indices = np.array(selected_features[2])\n\n      indices_names = 'Dummy'\n\n    make_pred = np.ones((num_samples, np_dat.shape[1]))*np_dat[index,:]\n    TERP_dat = np.zeros((num_samples, 1))\n\n    if numeric_indices.shape[0]&gt;0:\n          input_numeric = np_dat[:, numeric_indices]\n          numeric = copy.deepcopy(input_numeric)\n\n          std_numeric = []\n          for i in range(input_numeric.shape[1]):\n            std_numeric.append(np.std(input_numeric[:,i]))\n\n          make_prediction_numeric = np.zeros((num_samples, input_numeric.shape[1]))\n          TERP_numeric = np.zeros((num_samples, input_numeric.shape[1]))\n\n          perturb_numeric = np.random.randint(0, 2, num_samples * input_numeric.shape[1]).reshape((num_samples, input_numeric.shape[1]))\n          perturb_numeric[0,:] = 1\n\n          for i in range(num_samples):\n            for j in range(input_numeric.shape[1]):\n              if perturb_numeric[i,j] == 1:\n                make_prediction_numeric[i,j] = input_numeric[index,j]\n              elif perturb_numeric[i,j] == 0:\n                rand_data = np.random.normal(0, 1)\n                make_prediction_numeric[i,j] = input_numeric[index,j] + std_numeric[j]*rand_data\n                TERP_numeric[i,j] = rand_data\n\n          make_pred[:, numeric_indices] = make_prediction_numeric\n          TERP_dat = np.column_stack((TERP_dat, TERP_numeric))\n\n    if angle_indices.shape[0]&gt;0:\n      periodic = np_dat[:, angle_indices]\n      assert np.all(periodic&lt;=np.pi+0.001) and np.all(periodic&gt;-np.pi-0.001), 'Provide periodic data in appropriate domain...'\n      input_periodic = copy.deepcopy(periodic)\n\n      std_periodic = []\n      for i in range(input_periodic.shape[1]):\n        std_periodic.append(sst.circstd(input_periodic[:,i], high = np.pi, low = -np.pi))\n\n      make_prediction_periodic = np.zeros((num_samples, input_periodic.shape[1]))\n      TERP_periodic = np.zeros((num_samples, input_periodic.shape[1]))\n\n      perturb_periodic = np.random.randint(0, 2, num_samples * input_periodic.shape[1]).reshape((num_samples, input_periodic.shape[1]))\n      perturb_periodic[0,:] = 1\n\n      for i in range(num_samples):\n        for j in range(input_periodic.shape[1]):\n          if perturb_periodic[i,j] == 1:\n            make_prediction_periodic[i,j] = input_periodic[index,j]\n          elif perturb_periodic[i,j] == 0:\n            rand_data = np.random.normal(0, 1)\n            make_prediction_periodic[i,j] = input_periodic[index,j] + std_periodic[j]*rand_data\n            TERP_periodic[i,j] = rand_data\n            if make_prediction_periodic[i,j] &lt; period_low or make_prediction_periodic[i,j] &gt; period_high:\n              make_prediction_periodic[i,j] = np.arctan2(np.sin(make_prediction_periodic[i,j]), np.cos(make_prediction_periodic[i,j]))\n\n\n      make_pred[:, angle_indices] = make_prediction_periodic      \n      TERP_dat = np.column_stack((TERP_dat, TERP_periodic))\n\n    if sin_cos_indices.shape[0]&gt;0:\n      sin = np_dat[:, sin_cos_indices[:, 0]]\n      assert np.all(sin&gt;=-1) and np.all(sin&lt;=1), 'Provide sin data in domain [-1,1]'\n      input_sin = copy.deepcopy(sin)\n\n      cos = np_dat[:, sin_cos_indices[:, 1]]\n      assert np.all(cos&gt;=-1) and np.all(cos&lt;=1), 'Provide cosine data in domain [-1,1]'\n      input_cos = copy.deepcopy(cos)\n\n      std_sin_cos = []\n      input_sin_cos = np.zeros((input_sin.shape[0], input_sin.shape[1]))\n      for i in range(input_sin.shape[1]):\n        input_sin_cos[:,i] = np.arctan2(input_sin[:,i], input_cos[:,i])\n        std_sin_cos.append(sst.circstd(input_sin_cos[:,i], high = period_high, low = period_low))\n\n      make_prediction_sin = np.zeros((num_samples, input_sin_cos.shape[1]))\n      make_prediction_cos = np.zeros((num_samples, input_sin_cos.shape[1]))\n      TERP_sin_cos = np.zeros((num_samples, input_sin_cos.shape[1]))\n\n      perturb_sin_cos = np.random.randint(0, 2, num_samples * input_sin_cos.shape[1]).reshape((num_samples, input_sin_cos.shape[1]))\n      perturb_sin_cos[0,:] = 1\n\n      for i in range(num_samples):\n        for j in range(input_sin_cos.shape[1]):\n          if perturb_sin_cos[i,j] == 1:\n            make_prediction_sin[i,j] = np.sin(input_sin_cos[index,j])\n            make_prediction_cos[i,j] = np.cos(input_sin_cos[index,j])\n\n          elif perturb_sin_cos[i,j] == 0:\n            rand_data = np.random.normal(0, 1)\n            make_prediction_sin[i,j] = np.sin(input_sin_cos[index,j] + std_sin_cos[j]*rand_data)\n            make_prediction_cos[i,j] = np.cos(input_sin_cos[index,j] + std_sin_cos[j]*rand_data)\n            TERP_sin_cos[i,j] = rand_data\n\n\n      make_pred[:, sin_cos_indices[:, 0]] = make_prediction_sin\n      make_pred[:, sin_cos_indices[:, 1]] = make_prediction_cos\n\n      TERP_dat = np.column_stack((TERP_dat, TERP_sin_cos))\n\n    np.save(save_directory + '/make_prediction.npy', make_pred)  \n    np.save(save_directory + '/TERP_dat.npy', TERP_dat[:,1:])\n\n    return [numeric_indices, angle_indices, sin_cos_indices], indices_names\n</code></pre>"},{"location":"usage/","title":"Usage","text":"<p>To use MDTerp in a project:</p> <pre><code>import MDTerp\n</code></pre> <p>Go to https://shams-mehdi.github.io/MDTerp/MDTerp_intro.ipynb for explicit usage.</p>"},{"location":"utils/","title":"MDTerp module","text":"<p>MDTerp.utils.py \u2013 Auxiliary utility functions for MDTerp package.</p>"},{"location":"utils/#MDTerp.utils.input_summary","title":"<code>input_summary(logger, numeric_dict, angle_dict, sin_cos_dict, save_dir, np_data)</code>","text":"<p>Function for summarizing user-provided input data in Python Logger.</p> <p>Parameters:</p> Name Type Description Default <code>logger</code> <code>Logger</code> <p>Logger object created using Python's built-in logging module.</p> required <code>numeric_dict</code> <code>dict</code> <p>Python dictionary, each key represents the name of a numeric feature (non-periodic). Values should be lists with a single element with the index of the corresponding numpy array in np_data.</p> required <code>angle_dict</code> <code>dict</code> <p>Python dictionary, each key represents the name of an angular feature in [-pi, pi]. Values should be lists with a single element with the index of the corresponding numpy array in np_data.</p> required <code>sin_cos_dict</code> <code>dict</code> <p>Python dictionary, each key represents the name of an angular feature. Values should be lists with two elements with the sine, cosine indices respectively of the corresponding numpy array in np_data.</p> required <code>save_dir</code> <code>str</code> <p>Location to save MDTerp results.</p> required <code>np_data</code> <code>np.ndarray</code> <p>Numpy 2D array containing training data for the black-box model. Samples along rows and features along columns.</p> required <p>Returns:</p> Type Description <code>None</code> <p>None</p> Source code in <code>MDTerp/utils.py</code> <pre><code>def input_summary(logger: Logger, numeric_dict: dict, angle_dict: dict, sin_cos_dict: dict, save_dir: str, np_data: np.ndarray) -&gt; None:\n    \"\"\"\n    Function for summarizing user-provided input data in Python Logger.\n\n    Args:\n        logger (Logger): Logger object created using Python's built-in logging module.\n        numeric_dict (dict): Python dictionary, each key represents the name of a numeric feature (non-periodic). Values should be lists with a single element with the index of the corresponding numpy array in np_data.\n        angle_dict (dict): Python dictionary, each key represents the name of an angular feature in [-pi, pi]. Values should be lists with a single element with the index of the corresponding numpy array in np_data.\n        sin_cos_dict (dict): Python dictionary, each key represents the name of an angular feature. Values should be lists with two elements with the sine, cosine indices respectively of the corresponding numpy array in np_data.\n        save_dir (str): Location to save MDTerp results.\n        np_data (np.ndarray): Numpy 2D array containing training data for the black-box model. Samples along rows and features along columns.\n\n    Returns:\n        None\n    \"\"\"\n    logger.info('MDTerp result location &gt;&gt;&gt; ' + save_dir )\n    logger.info('Defined numeric features &gt;&gt;&gt; ' + str(len(list(numeric_dict.keys()))) )\n    logger.info('Defined angle features &gt;&gt;&gt; ' + str(len(list(angle_dict.keys()))) )\n    logger.info('Defined sin_cos features &gt;&gt;&gt; ' + str(len(list(sin_cos_dict.keys()))) )\n    logger.info('Number of samples in blackbox model training data &gt;&gt;&gt; ' + str(np_data.shape[0]) )\n    logger.info('Number of columns in blackbox model training data &gt;&gt;&gt; ' + str(np_data.shape[1]) )\n\n    if np_data.shape[1] != len(list(numeric_dict.keys())) + len(list(angle_dict.keys())) + len(list(sin_cos_dict.keys()))//2:\n        logger.error('Assertion failure between provided feature dictionaries and input data!')\n        raise ValueError('Assertion failure between provided feature dictionaries and input data!')\n\n    logger.info(100*'-')\n</code></pre>"},{"location":"utils/#MDTerp.utils.log_maker","title":"<code>log_maker(save_dir)</code>","text":"<p>Function for creating a logger detailing MDTerp operations.</p> <p>Parameters:</p> Name Type Description Default <code>save_dir</code> <code>str</code> <p>Location to save MDTerp results.</p> required <p>Returns:</p> Type Description <code>Logger</code> <p>Logger object created using Python's built-in logging module.</p> Source code in <code>MDTerp/utils.py</code> <pre><code>def log_maker(save_dir: str) -&gt; Logger:\n    \"\"\"\n    Function for creating a logger detailing MDTerp operations.\n\n    Args:\n        save_dir (str): Location to save MDTerp results.\n\n    Returns:\n        Logger: Logger object created using Python's built-in logging module.\n    \"\"\"\n    fmt = '%(asctime)s %(name)-15s %(levelname)-8s %(message)s'\n    datefmt='%m-%d-%y %H:%M:%S'\n    logging.basicConfig(level=logging.INFO,format=fmt,datefmt=datefmt,filename=save_dir+'/MDTerp_summary.log',filemode='w')\n    logger = logging.getLogger('initialization')\n    console_handler = logging.StreamHandler()\n    console_handler.setLevel(logging.INFO)\n    formatter = logging.Formatter(fmt,datefmt=datefmt)\n    console_handler.setFormatter(formatter)\n    logger.addHandler(console_handler)\n    logger.info(100*'-')\n    logger.info('Starting MDTerp...')\n    logger.info(100*'-')\n\n    return logger\n</code></pre>"},{"location":"utils/#MDTerp.utils.picker_fn","title":"<code>picker_fn(prob, threshold, point_max)</code>","text":"<p>Function for picking points at the transition state ensemble. Uses provided data and metastable state probability from black-box.</p> <p>Parameters:</p> Name Type Description Default <code>prob</code> <code>np.ndarray</code> <p>Numpy 2D array containing metastable state prediction probabilities from the black-box model. Rows represent samples and number of columns equal to number of states. Each row should sum to 1.</p> required <code>threshold</code> <code>float</code> <p>Threshold for identifying if a sample belongs to transition state predicted by the black-box model. If metastable state probability &gt; threshold for two different classes for a specific sample, it's suitable for analysis.</p> required <code>point_max</code> <code>int</code> <p>If too many suitable points exist for a specific transition (e.g., transition between metastable state 3 and 8), point_max sets maximum number of points chosen for analysis. Points chosen from a uniform distribution.</p> required <p>Returns:</p> Type Description <code>dict </code> <p>Dictionary with keys representing detected transitions. E.g., key '3_8' means transition between index 3 and index 8 in according to the prob array. Values represent chosen samples/rows in the provided dataset which undergo this transition.</p> Source code in <code>MDTerp/utils.py</code> <pre><code>def picker_fn(prob: np.ndarray, threshold: float, point_max: int) -&gt; dict:\n    \"\"\"\n    Function for picking points at the transition state ensemble. Uses provided data and metastable state probability from black-box.\n\n    Args:\n        prob (np.ndarray): Numpy 2D array containing metastable state prediction probabilities from the black-box model. Rows represent samples and number of columns equal to number of states. Each row should sum to 1.\n        threshold (float): Threshold for identifying if a sample belongs to transition state predicted by the black-box model. If metastable state probability &gt; threshold for two different classes for a specific sample, it's suitable for analysis.\n        point_max (int): If too many suitable points exist for a specific transition (e.g., transition between metastable state 3 and 8), point_max sets maximum number of points chosen for analysis. Points chosen from a uniform distribution.\n\n    Returns:\n        dict : Dictionary with keys representing detected transitions. E.g., key '3_8' means transition between index 3 and index 8 in according to the prob array. Values represent chosen samples/rows in the provided dataset which undergo this transition.\n    \"\"\"\n    transition_dict = defaultdict(list)\n    for i in range(prob.shape[0]):\n        sorted_ind = np.sort(np.argsort(prob[i, :])[::-1][:2])\n        sorted_val = np.sort(prob[i, :])[::-1][:2]\n        if (sorted_val[0]&gt;=threshold) and (sorted_val[1]&gt;=threshold):\n            transition_dict[str(sorted_ind[0]) + '_' + str(sorted_ind[1])].append(i)\n    for i in transition_dict.keys():\n        transition_dict[i] = np.random.choice(transition_dict[i], size = min(point_max, len(transition_dict[i])), replace = False)\n\n    return transition_dict\n</code></pre>"},{"location":"utils/#MDTerp.utils.summary","title":"<code>summary(feature_names_loc, all_result_loc, save_fig_dir, top_k=10, fs=12, dpi=300)</code>","text":"<p>Function summarizing MDTerp results for all the transitions present in the dataset.</p> <p>Parameters:</p> Name Type Description Default <code>feature_names_loc</code> <code>str</code> <p>Location of the saved combined (all) feature names.</p> required <code>all_results_loc</code> <code>str</code> <p>Location to save MDTerp results.</p> required <code>save_fig_dir</code> <code>str</code> <p>Location to save MDTerp results figures.</p> required <code>top_k</code> <code>int</code> <p>Number of top ranked features to show in summary figures.</p> <code>10</code> <code>fs</code> <code>int</code> <p>Fontsize of the labels in generated figures.</p> <code>12</code> <code>dpi</code> <code>int</code> <p>DPI of the generated figures</p> <code>300</code> <p>Returns:</p> Type Description <code>dict </code> <p>Dictionary with keys representing detected transitions. E.g., key '3_8' means transition between index 3 and index 8 in according to the prob array. Values are lists representing feature importance with length of the list equaling number of features in the provided dataset.</p> Source code in <code>MDTerp/utils.py</code> <pre><code>def summary(feature_names_loc: str, all_result_loc: str, save_fig_dir: str, top_k: int = 10, fs: int = 12, dpi: int = 300) -&gt; dict:\n    \"\"\"\n    Function summarizing MDTerp results for all the transitions present in the dataset.\n\n    Args:\n        feature_names_loc (str): Location of the saved combined (all) feature names.\n        all_results_loc (str): Location to save MDTerp results.\n        save_fig_dir (str): Location to save MDTerp results figures.\n        top_k (int): Number of top ranked features to show in summary figures.\n        fs (int): Fontsize of the labels in generated figures.\n        dpi (int): DPI of the generated figures\n\n    Returns:\n        dict : Dictionary with keys representing detected transitions. E.g., key '3_8' means transition between index 3 and index 8 in according to the prob array. Values are lists representing feature importance with length of the list equaling number of features in the provided dataset.\n    \"\"\"\n    feature_names = np.load(feature_names_loc)\n    os.makedirs(save_fig_dir, exist_ok = True)\n    with open(all_result_loc, 'rb') as f:\n        loaded_dict = pickle.load(f)  \n    transitions = []\n    for ii in loaded_dict:\n        transitions.append(loaded_dict[ii][0])\n    summary_imp = {}\n    for ii in np.unique(transitions):\n        summary_imp[ii] = []\n    for ii in loaded_dict:\n        summary_imp[loaded_dict[ii][0]].append(loaded_dict[ii][1])\n    for ii in summary_imp:\n        summary_imp[ii] = np.mean(summary_imp[ii], axis = 0)\n        tmp_vals = summary_imp[ii]\n        trim_args = np.argsort(tmp_vals)[::-1][:top_k]\n        trim_vals = np.sort(tmp_vals)[::-1][:top_k]\n        fig, ax = plt.subplots(figsize = (8,8))\n        ax.barh(np.arange(trim_vals.shape[0]), trim_vals)\n        ax.set_title('Importance coverage: ' + str(int(100*np.sum(trim_vals)/np.sum(tmp_vals))) + '%', fontsize = fs)\n        ax.tick_params(axis='both', which='major', labelsize=fs)\n        ax.tick_params(axis='both', which='minor', labelsize=int(fs/2))\n        ax.set_yticks(np.arange(trim_args.shape[0]))\n        ax.set_yticklabels(np.array(feature_names)[trim_args])\n        fig.tight_layout()\n        fig.savefig(save_fig_dir + '/' + ii + '.png', dpi = dpi, transparent = True)\n\n    return summary_imp\n</code></pre>"}]}